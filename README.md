## Книга "Java полное руководство - Герберт Шилдт, 12-е издание, 2022г."

<small>

#### Оглавление

<details ГЛАВА 13><summary>ГЛАВА 13. "Ввод-вывод, оператор try с ресурсами и др."</summary>
<blockquote>

<details><summary>Ввод-вывод</summary>

Поддержка ввода-вывода обеспечивается основными библиотеками Java API, а не системными библиотеками языка.

<details><summary>Потоки данных</summary>

Ввод и вывод данных в Java-программах осуществляется через потоки данных. Поток данных - это абстракция, которая может производить или потреблять информацию. Поток связывается с физическим устройством посредством системы ввода-вывода Java. Классы и методы ввода-вывода можно применять к различным типам устройств, таким как дисковые файлы, клавиатура или сетевые соединения. Это позволяет абстрагироваться от множества различных видов ввода. Вывод данных может осуществляться на консоль, в дисковый файл или по сетевому соединению. Потоки данных в Java реализованы в иерархиях классов, определенных в пакете java.io.

Java также предоставляет ввод-вывод на основе буферов и каналов, которые определены в пакете java.nio и его подпакетах.

</details>

<details><summary>Потоки байтовых и символьных данных</summary>

В Java существуют два типа потоков ввода/вывода: байтовые и символьные. Байтовые потоки удобны для обработки ввода и вывода байтовых данных, например при чтении или записи двоичных данных. Символьные потоки используют Unicode и позволяют обрабатывать ввод и вывод символов, обеспечивая поддержку интернационализации. В некоторых случаях символьные потоки более эффективны, чем байтовые.

На самом низком уровне операции ввода-вывода по-прежнему выполняются с байтами. Символьные потоки предоставляют удобный и эффективный способ работы со символами в кодировке Unicode.
  
</details>

<details><summary>Классы потоков байтовых данных</summary>

**Классы потоков ввода-вывода байтов из пакета java.io**

Потоки ввода-вывода байтов определены в двух иерархиях классов. На вершине этих иерархий находятся _абстрактные классы InputStream и OutputStream_. У каждого из этих абстрактных классов имеется несколько конкретных подклассов, в которых учитываются отличия разных устройств, в том числе файлов на диске, сетевых соединений и даже буферов памяти.

```html
BufferedInputStream    Буферизованный поток ввода  
BufferedOutputStream   Буферизованный поток вывода  
ByteArrayinputStream   Поток ввода, читающий байты из массива  
ByteArrayOutputStream  Поток вывода, записывающий байты в массив  
DataInputStream        Поток ввода, содержащий методы для чтения данных стандартных типов, определенных в Java  
DataOutputStream       Поток вывода, содержащий методы для записи данных стандартных типов, определенных в Java  
FileInputStream        Поток ввода, читающий данные из файла  
FileOutputStream       Поток вывода, записывающий данные в файл  
FilterInputStream      Реализует абстрактный класс InputStream  
FilterOutputStream     Реализует абстрактный класс OutputStream  
InputStream            Абстрактный класс, описывающий поток ввода  
ObjectInputStream      Поток ввода объектов  
ObjectOutputstream     Поток вывода объектов  
OutputStream           Абстрактный класс, описывающий поток вывода  
PipedInputStream       Канал ввода  
PipedOutputstream      Канал вывода  
PrintStream            Поток вывода, содержащий методы print() и println()  
PushbackInputStream    Поток ввода, поддерживающий возврат одного байта обратно в поток ввода  
SequenceInputStream    Поток ввода, состоящий из нескольких потоков ввода, данные из которых читаются по очереди  
```

В абстрактных классах InputStream и OutputStream определяется ряд ключевых методов, реализуемых в других классах потоков ввода-вывода. Наиболее важными среди них являются методы read() и writе(), читающие и записывающие байты данных соответственно. Оба эти метода объявлены как абстрактные в классах InputStream и OutputStream, а в производных классах они переопределяются.

**Классы потоков ввода-вывода символов**

Потоки ввода-вывода символов также определены в двух иерархиях классов. На вершине этих иерархий находятся два * абстрактных* класса - Reader и Writer. Эти абстрактные классы управляют потоками символов в Юникоде. Для каждого из них в Java предусмотрен ряд конкретных подклассов.

```html
BufferedReader         Буферизированный поток ввода символов  
BufferedWriter         Буферизированный поток вывода символов  
CharArrayReader        Поток ввода, читающий символы из массива  
CharArrayWriter        Поток вывода, записывающий символы в массив  
FileReader             Поток ввода, читающий символы из файла  
FileWriter             Поток вывода, записывающий символы в файл  
FilterReader           Фильтрованный поток чтения  
FilterWriter           Фильтрованный поток запис  
InputStreamReader      Поток ввода, преобразующий байты в символы  
LineNumЬerReader       Поток ввода, подсчитывающий строки  
OutputStreamWriter     Поток вывода, преобразующий символы в байты  
PipedReader            Канал ввода  
PipedWriter            Канал вывода  
PrintWriter            Поток вывода, содержащий методы print() и println()  
PushbackReader         Поток ввода, позволяющий возвращать символы обратно в поток ввода  
Reader                 Абстрактный класс, описывающий поток ввода символов  
StringReader           Поток ввода, читающий символы из строки  
StringWriter           Поток вывода, записывающий символы в строку  
Writer                 Абстрактный класс, описывающий поток вывода символов   
```

В абстрактных классах Reader и Writer определяется ряд ключевых методов, реализуемых в других классах потоков ввода-вывода. Наиболее важными среди них являются методы read() и write(), читающие и записывающие байты данных соответственно. Оба эти метода объявлены как абстрактные в классах Reader и Writer, а в производных классах они переопределяются.

</details>

<details><summary>Предопределенные потоки данных</summary>

Класс System содержит несколько методов для получения информации о системе и текущего времени, а также три предопределенных потоковых переменных: in, out и err, которые могут быть использованы в любой части программы без привязки к конкретному экземпляру класса System.

Переменная System.out ссылается на поток стандартного вывода, по умолчанию вывод осуществляется на консоль. System.in ссылается на поток стандартного ввода, по умолчанию принимаемые данные поступают с клавиатуры. System.err ссылается на поток вывода ошибок, также по умолчанию вывод ошибок осуществляется на консоль. Эти потоки могут быть перенаправлены на другие устройства ввода-вывода, поддерживающие совместимые форматы данных.

System.in, System.out и System.err являются потоками байтовых данных типа InputStream, PrintStream и ErrorStream соответственно. Однако они обычно используются для чтения и записи символов в консоль. Вы можете использовать их как основу для более сложных операций ввода-вывода или обернуть их в классы символьных потоков для дополнительной гибкости и контроля.

</details>

<details><summary>Чтение консольного ввода</summary>

История Java и консольный ввод:
   - На заре развития Java единственным способом выполнения консольного ввода было использование потока байтовых данных.
   - В настоящее время символьный поток предпочтительнее из-за удобства интернационализации и сопровождения программы.

Java 17 и изменения:
   - В JDK 17 изменился способ получения объекта InputStreamReader, связанного с System.in.
   - Рекомендуется явно указывать набор символов, ассоциированный с консолью, при создании InputStreamReader. Набор символов определяет способ сопоставления байтов с символами. Обычно, когда набор символов не задан, применяется стандартная кодировка 
JVM.

Использование InputStreamReader и BufferedReader:
   - Для чтения консольного ввода через BufferedReader, рекомендуется использовать конструктор InputStreamReader с явным указанием набора символов, ассоциированного с консолью.
   - Можно использовать метод System.console() для получения объекта Console и его метод charset() для получения набора символов консоли.

Создание BufferedReader с использованием InputStreamReader без явного указания набора символов (до JDK 17):

```html
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class ConsoleInputExample {
    public static void main(String[] args) {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        try {
            System.out.print("Введите ваше имя: ");
            String name = br.readLine();
            System.out.println("Привет, " + name + "!");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

Создание BufferedReader с использованием InputStreamReader с явным указанием набора символов (начиная с JDK 17):
 
```html
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.Charset;

public class ConsoleInputExample {
    public static void main(String[] args) {
        InputStreamReader isr = new InputStreamReader(System.in, Charset.defaultCharset());
        BufferedReader br = new BufferedReader(isr);

        try {
            System.out.print("Введите ваше имя: ");
            String name = br.readLine();
            System.out.println("Привет, " + name + "!");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

Современный подход к чтению консольного ввода в Java включает явное указание набора символов консоли при создании InputStreamReader, что обеспечивает более надежное и удобное взаимодействие с консолью в различных приложениях.

</details>

<details><summary>Чтение символов</summary>

Чтобы получить поток ввода символов, присоединив его к консоли, следует заключить стандартный поток ввода System.in в оболочку объекта класса BufferedReader, поддерживающего буферизованный поток ввода. Ниже приведен чаще всего используемый конструктор этого класса.

```html
BufferedReader(Reader поток_чтения_вводимых_данных)  
```

десь параметр поток_чтения_вводимых_данных обозначает поток, который связывается с создаваемым экземпляром класса BufferedReader. Класс Reader является абстрактным. Одним из производных от него конкретных подклассов является класс InputStreamReader, преобразующий байты в символы. Для получения объекта типа InputStreamReader, связанного со стандартным потоком ввода System.in, служит следующий конструктор:

```html
InputStreamReader(InputStream поток_ввода)   
```

Переменная System.in ссылается на объект класса InputStream и поэтому должна быть указана в качестве параметра поток_ввода. В конечном итоге получается приведенная ниже строка кода, где создается объект типа BufferedReader, связанный с клавиатурой. После выполнения этой строки кода переменная экземпляра br будет содержать поток ввода символов, связанный с консолью через стандартный поток ввода System.in.

```html
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
```

Для чтения символа из потока ввода типа BufferedReader служит метод read(). Ниже приведена общая форма метода read().

```html
int read() throws IOException  
```

Всякий раз, когда метод read() вызывается, он читает символ из потока ввода и возвращает его в виде целочисленного значения. По достижении конца потока возвращается значение -1. Как видите, метод read() может сгенерировать исключение типа IOException.

[Chapter13/Package01/BRRead - Использовать класс BufferedReader для чтения символов с консоли](https://github.com/Vladlena2/BookJava2/blob/main/Chapter13/Package01/BRRead.java "Посмотреть пример Java")

Для чтения символьных строк с клавиатуры служит версия метода readLine(), который является членом класса BufferedReader. Его общая форма приведена ниже. Как видите, этот метод возвращает объект типа String.

```html
String readLine() throws IOException    
```

[Chapter13/Package01/BRReadLines - Чтение символьных строк с консоли средствами класса BufferedReader](https://github.com/Vladlena2/BookJava2/blob/main/Chapter13/Package01/BRReadLines.java "Посмотреть пример Java")

В следующем далее примере программы демонстрируется простейший текстовый редактор. С этой целью сначала создается массив объектов типа String, а затем читаются текстовые строки, каждая из которых сохраняется в элементе массива. Чтение производится до 100 строк или до тех пор, пока не будет введено слово "стоп". Для чтения данных с консоли применяется класс BufferedReader.

[Chapter13/Package01/TinyEdit - Простейший текстовый редактор](https://github.com/Vladlena2/BookJava2/blob/main/Chapter13/Package01/TinyEdit.java "Посмотреть пример Java")

</details>

<details><summary>Запись данных, выводимых на консоль</summary>

Вывод данных на консоль проще всего организовать с помощью упоминавшихся ранее методов print() и println(). Эти методы определены в классе PrintStream (он является типом объекта, на который ссылается переменная System.out).

Класс PrintStream описывает поток вывода и является производным от класса OutputStream, поэтому в нем реализуется также низкоуровневый метод write(). Следовательно, метод write() можно применять для записи данных, выводимых на консоль. Ниже приведена простейшая форма метода writе(), определенного в классе PrintStream.

```html
void write(int байтовое_значение)     
```

Этот метод записывает байт, передаваемый в качестве параметра байтовое_значение. Несмотря на то что параметр * байтовое_значение* объявлен как целочисленный, записываются только 8 его младших бит. Ниже приведен короткий пример программы, где метод write() применяется для вывода на экран буквы "А" с последующим переводом строки.

```html
// Продемонстрировать применение метода System.out.write()
class WriteDemo {
   public static void main(String[] args){
       int b;
       b = 'A';
       System.out.write(b);
       System.out.print("\n");
   }
}   
```

**Класс PrintWriter**

Применение класса PrintWriter для консольного вывода упрощает интернационализацию прикладных программ. В классе PrintWriter определяется несколько конструкторов. Ниже приведен один из тех конструкторов:

```html
PrintWriter(OutputStream поток_вывода, boolean очистка)   
```

Здесь параметр поток_вывода обозначает объект типа OutputStream, а параметр очистка - очистку потока вывода всякий раз, когда вызывается (среди прочих) метод println(). Если параметр очистка принимает логическое значение true, то очистка потока вывода происходит автоматически, а иначе - вручную.

В классе PrintWriter поддерживаются методы print() и println(). Следовательно, их можно использовать таким же образом, как и в стандартном по токе вывода System.out. Если аргумент этих методов не относится к простому типу, то для объекта типа PrintWriter сначала вызывается метод toString(), а затем выводится результат.

Чтобы вывести данные на консоль, используя класс PrintWriter, следует указать стандартный поток System.out для вывода и его автоматическую очистку. Например, в следующей строке кода создается объект типа PrintWriter, который связывается с консольным выводом:

```html
PrintWriter pw = new PrintWriter(System.out, true);
```

[Chapter13/Package01/PrintWriterDemo - Продемонстрировать применение класса PrintWriter](https://github.com/Vladlena2/BookJava2/blob/main/Chapter13/Package01/PrintWriterDemo.java "Посмотреть пример Java")
       
</details>

<details><summary>Чтение файлов и запись в файлы</summary>

Для ввода-вывода данных в файлы чаще всего применяются классы FileInputStream и FileOutputStream, которые создают потоки ввода-вывода байтов, связанные с файлами. Чтобы открыть файл для ввода-вывода данных, достаточно создать объект одного из этих классов, указав имя файла в качестве аргумента конструктора. У обоих классов имеются и дополнительные конструкторы, но в представленных далее примерах будут употребляться только следующие конструкторы:

```html
FileInputStream(String имя_файла)
   throws FileNotFoundException
FileOutputStream(String имя_файла)
   throws FileNotFoundException
```

Здесь параметр имя_файла обозначает имя того файла, который требуется открыть. Если при создании потока ввода файл не существует, то генерируется исключение типа FileNotFoundException. А если при создании потока вывода файл нельзя открыть или создать, то и в этом случае генерируется исключение типа FileNotFoundException. Класс исключения FileNotFoundException является производным от класса IOException. Когда файл открыт для вывода, любой файл, существовавший ранее под тем же самым именем, уничтожается.

Завершив работу с файлом, его нужно закрыть. Для этой цели служит метод close(), реализованный в классах FileinputStream и F ileOutputStream:

```html
void close() throws IOException
```

Закрытие файла высвобождает выделенные для него системные ресурсы, позволяя использовать их для других файлов. Неудачный исход закрытия файла может привести к **"утечкам памяти"**, поскольку неиспользуемые ресурсы оперативной памяти останутся выделенными.

**На заметку!**

Начиная с версии JDK 7, метод close() определяется в интерфейсе АutоСlоsеаblе из пакета java.lang. Интерфейс * АutоСlовеаblе* наследует от интерфейса Closeable из пакета java.io. Оба интерфейса реализуются классами потоков ввода-вывода, включая классы FileinputStream и FileOutputStream.

Чтобы прочитать данные из файла, можно воспользоваться формой метода read(), определенной в классе FileInputStream. Та его форма, которая применяется в представленных далее примерах, выглядит следующим образом:

```html
int read() throws IOException
```

Всякий раз, когда вызывается метод read(), он выполняет чтение одного байта из файла и возвращает ero в виде целочисленного значения. А если достигнут конец файла, то возвращается значение -1. Этот метод может сгенерировать исключение типа IOException.

В приведенном ниже примере программы метод read() применяется для ввода из файла, содержащего текст в коде ASCII, который затем выводится на экран. Имя файла указывается в качестве аргумента командной строки.

```html
java ShowFile TEST.txt
```

[Chapter13/Package02/ShowFile - Отображение содержимого текстового файла](https://github.com/Vladlena2/BookJava2/blob/main/Chapter13/Package02/ShowFile.java "Посмотреть пример Java")
       

Иногда проще заключить все части программы, открывающие файл и получающие доступ к его содержимому, в один блок оператора try, вместо того чтобы разделять его на два блока, а затем закрыть файл в блоке оператора finally. В качестве иллюстрации ниже показан другой способ написания программы

[Chapter13/Package02/ShowFile2 - ShowFile из предыдущего примера.](https://github.com/Vladlena2/BookJava2/blob/main/Chapter13/Package02/ShowFile2.java "Посмотреть пример Java")

[Chapter13/Package02/ShowFile3 - Отображение содержимого текстового файла в одном блоке оператора try](https://github.com/Vladlena2/BookJava2/blob/main/Chapter13/Package02/ShowFile3.java "Посмотреть пример Java")

Класс исключения FileNotFoundException является производным от класса IOException, и поэтому обрабатывать отдельно его исключение совсем не обязательно. В качестве примера ниже приведена переделанная последовательность операторов try/catch без перехвата исключения типа FileNotFoundException. В данном случае отображается стандартное сообщение об исключительной ситуации, описывающее возникшую ошибку.

[Chapter13/Package02/ShowFile4 - Переделанная последовательность операторов try/catch](https://github.com/Vladlena2/BookJava2/blob/main/Chapter13/Package02/ShowFile4.java "Посмотреть пример Java")

Для записи в файл можно воспользоваться методом writе(), определенным в классе FileOutputStream. В своей простейшей форме этот метод выглядит следующим образом:

```html
void write(int байтовое_значение) throws IOException
```

Этот метод записывает в файл байт, переданный ему в качестве параметра байтовое_значение. Несмотря на то что параметр байтовое_значение объявлен как целочисленный, в файл записываются только его младшие восемь бит. Если при записи возникает ошибка, генерируется исключение типа IOException. В следующем примере программы метод writе() применяется для копирования файла.

Обратите внимание на то, что в данном примере программы при закрытии файлов используются два отдельных блока оператора try. Этим гарантируется, что оба файла будут закрыты, даже если при вызове метода fin.close() будет сгенерировано исключение.

[Chapter13/Package02/CopyFile - Копирование файла](https://github.com/Vladlena2/BookJava2/blob/main/Chapter13/Package02/CopyFile.java "Посмотреть пример Java")

Исключения в Java не только упрощают обращение с файлами, но и позволяют легко отличать условие достижения конца файла от ошибок во время ввода в файл.

</details>

<details><summary>Автоматическое закрытие файла</summary>

В версии JDK 7 появилась новая возможность, предлагающая иной способ управления такими ресурсами, как потоки
ввода-вывода в файлы: *автоматическое завершение процесса*. Эту возможность иногда еще называют
**автоматическим управлением ресурсами (ARM)**, и основывается она на усовершенствованной версии оператора try. Главное
преимущество автоматического
управления ресурсами заключается в предотвращении ситуаций, когда файл (или другой ресурс) не освобождается по
невнимательности, если он больше не нужен.

Запомните: если забыть по какой-нибудь причине закрыть файл, это может привести к утечке памяти и другим осложнениям.
Ниже приведена *усовершенствованная* форма оператора try.
```java
try (спецификация_ресурса) {
     // использование ресурса
}
```

Здесь *спецификация_ресурса*, как правило, обозначает оператор, объявляющий и инициализирующий такой ресурс, как *поток
ввода-вывода данных в файл*.

Он состоит из объявления переменной, где переменная инициализируется ссылкой на управляемый объект. По завершении блока
оператора try ресурс автоматически освобождается. Для файла это означает, что он автоматически закрывается, а
следовательно, отпадает необходимость вызывать метод close() явным образом.
Она называется оператором try с *ресурсами*.

Оператор try с ресурсами можно применять лишь вместе с теми ресурсами, в которых реализован интерфейс AutoCloseaЬle,
определенный в пакете java.lang. В этом интерфейсе определен метод close(), а наследует он от интерфейса Closeable из
пакета java.io. Оба интерфейса реализуются классами потоков ввода-вывода. Таким образом, оператор try с ресурсами
можно
применять для работы с потоками ввода и вывода, в том числе и в файлы.

[Chapter13/Package02/ShowFileAutoClose - Пример оператора try с ресурсами](https://github.com/Vladlena2/BookJava2/blob/master/Chapter13/Package02/ShowFileAutoClose.java "Посмотреть пример Java")

Ресурс, объявляемый в операторе try, неявно считается конечным. Это означает, что присвоить ресурс после того, как он
был создан, нельзя. Кроме того, область действия ресурса ограничивается пределами оператора try с ресурсами.

В одном операторе try можно организовать управление несколькими ресурсами. Для этого достаточно указать спецификацию
каждого ресурса через точку с запятой. Примером тому служит приведенная ниже версия программы CopyFile, переделанная
таким образом, чтобы использовать один оператор try с ресурсами для управления переменными fin и fout.

[Chapter13/Package02/CopyFileAutoClose - Пример оператора try с двумя ресурсами](https://github.com/Vladlena2/BookJava2/blob/master/Chapter13/Package02/CopyFileAutoClose.java "Посмотреть пример Java")

У оператора *try с ресурсами* имеется еще одна особенность, о которой стоит упомянуть. Когда выполняется блок оператора
try, существует вероятность того, что исключение, возникающее в блоке оператора try, приведет к другому исключению,
которое произойдет в тот момент, когда ресурс закрывается
в блоке оператора finally. Если это обычный оператор try, то первоначальное исключение теряется, будучи вытесненным
вторым исключением. А если используется оператор try с ресурсами, то второе исключение подавляется, но не теряется.
Вместо этого оно добавляется в список подавленных исключений, связанных
с первым исключением. Доступ к списку подавленных исключений может быть пол учен с помощью метода gеtSupprеssеd(),
определенного в классе Throwаblе.
</details>

<details><summary>Чтение и запись файлов. FileInputStream и FileOutputStream</summary>

**Запись файлов и класс FileOutputStream**

Класс *FileOutputStream* предназначен для записи байтов в файл. Он является производным от класса OutputStream, поэтому
наследует всю его функциональность.
Через конструктор класса FileOutputStream задается файл, в который производится запись. Класс поддерживает несколько
конструкторов:
```java
FileOutputStream(String filePath)
FileOutputStream(File fileObj)
FileOutputStream(String filePath, boolean append)
FileOutputStream(File fileObj, boolean append)
```
Файл задается либо через строковый путь, либо через объект File. Второй параметр - append задает способ записи: eсли он
равен true, то данные дозаписываются в конец файла, а при false - файл полностью перезаписывается.  
Например, запишем в файл строку:

[Chapter13/Package02/WriteFile - Пример записи строки в файл TEST.txt](https://github.com/Vladlena2/BookJava2/blob/master/Chapter13/Package02/WriteFile.java "Посмотреть пример Java")

Для создания объекта FileOutputStream используется конструктор, принимающий в качестве параметра путь к файлу для
записи. Если такого файла нет, то он автоматически создается при записи. Так как здесь записываем строку, то ее надо
сначала перевести в массив байтов. И с помощью метода write строка записывается в файл.
При этом необязательно записывать весь массив байтов. Используя перегрузку метода write(), можно записать и одиночный
байт:
```java
fos.write(buffer[0]); // запись первого байта
```

**Чтение файлов и класс FileInputStream**

Для считывания данных из файла предназначен класс *FileInputStream*, который является наследником класса InputStream и
поэтому реализует все его методы.

Для создания объекта FileInputStream мы можем использовать ряд конструкторов. Наиболее используемая версия конструктора
в качестве параметра принимает путь к считываемому файлу:
```java
FileInputStream(String fileName) throws FileNotFoundException
```
Если файл не может быть открыт, например, по указанному пути такого файла не существует, то генерируется исключение *
FileNotFoundException*.  
Считаем данные из ранее записанного файла (TEST.txt) и выведем на консоль:

[Chapter13/Package02/ReadFile - Пример чтения файла TEST.txt](https://github.com/Vladlena2/BookJava2/blob/master/Chapter13/Package02/ReadFile.java "Посмотреть пример Java")

В данном случае мы считываем каждый отдельный байт в переменную i:
```java
while((i = fin.read()) != -1) {
```
Когда в потоке больше нет данных для чтения, метод возвращает число -1.
Затем каждый считанный байт конвертируется в объект типа char и выводится на консоль.  
Подобным образом можно считать данные в массив байтов и затем производить с ним манипуляции:
```java
byte[] buffer = new byte[fin.available()];
// считаем файл в буфер
fin.read(buffer, 0, fin.available());

System.out.println("File data:");
for(int i=0; i<buffer.length;i++){
    System.out.print((char)buffer[i]);
}
```

Совместим оба класса и выполним чтение из одного и запись в другой файл:

[Chapter13/Package02/ReadWriteFile - Пример чтение из одного и запись в другой файл](https://github.com/Vladlena2/BookJava2/blob/master/Chapter13/Package02/ReadWriteFile.java "Посмотреть пример Java")

Классы FileInputStream и FileOutputStream предназначены прежде всего для записи двоичных файлов, то есть для записи и
чтения байтов. И хотя они также могут использоваться для работы с текстовыми файлами, но все же для этой задачи больше
подходят другие классы.

Еще один пример, в котором создаем для записи файл, далее записываем в него строку.  
Потом читаем и выводим на конслоь данные из этого файла и все это копируем в новый файл.

[Chapter13/Package02/WriteReadSaveToFile - Создание, чтение одного файла и копирование в другой файл](https://github.com/Vladlena2/BookJava2/blob/master/Chapter13/Package02/WriteReadSaveToFile.java "Посмотреть пример Java")
</details>

<details><summary>Чтение и запись текстовых файлов. Класс FileWriter. Класс FileReader</summary>

Для полноценной работы с текстовыми файлами служат совсем другие классы, которые являются наследниками абстрактных
классов *Reader* и *Writer*.

Класс *FileWriter* является производным от класса *Writer*. Он используется для записи текстовых файлов.
Чтобы создать объект *FileWriter*, можно использовать один из следующих конструкторов:
```
FileWriter(File file)
FileWriter(File file, boolean append)
FileWriter(FileDescriptor fd)
FileWriter(String fileName)
FileWriter(String fileName, boolean append)
```  
Так, в конструктор передается либо путь к файлу в виде строки, либо объект File, который ссылается на конкретный
текстовый файл. Параметр *append* указывает, должны ли данные дозаписываться в конец файла (если параметр равен true),
либо файл должен перезаписываться.

Класс *FileReader* наследуется от абстрактного класса *Reader* и предоставляет функциональность для чтения текстовых
файлов.
Для создания объекта *FileReader* мы можем использовать один из его конструкторов:
```java
FileReader(String fileName) 
FileReader(File file)
FileReader(FileDescriptor fd)
```  

[Chapter13/Package02/FileWriterReaderDemo - Записать текст в файл и прочитать](https://github.com/Vladlena2/BookJava2/blob/master/Chapter13/Package02/FileWriterReaderDemo.java "Посмотреть пример Java")
</details>

<details><summary>Модификаторы доступа transient и volatile</summary>

В языке J ava определяются два интересных модификатора доступа: *transient* и *volatile*. Эти модификаторы
предназначены для особых случаев. Когда переменная-экземпляр объявлена как transient, ее значение не должно
сохраняться, когда сохраняется объект, как показано ниже.

```java
class T {
    transient int а; //не сохранится
    int b; // сохранится
} 
```

Если в данном примере кода объект типа т записывается в область постоянного хранения, то содержимое переменной а не
должно сохраняться, тогда как содержимое переменной b должно быть сохранено.

Модификатор доступа volatile сообщает компилятору, что модифицируемая им переменная может быть неожиданно изменена в
других частях программы.
Одна из таких ситуаций возникает в многопоточных программах, где иногда в двух или больше потоках исполнения
разделяется
общая переменная. Из соображений эффективности в каждом потоке может храниться своя закрытая копия этой
переменной. Настоящая (или главная) копия переменной обновляется в разные моменты, например при входе в
синхронизированный метод. Такой подход вполне работоспособен, но не всегда оказывается достаточно эффективным. Иногда
требуется, чтобы главная копия переменной постоянно отражала ее текущее состояние. И для этого достаточно объявить
переменную как volatile, предписав тем самым компилятору всегда использовать главную копию этой переменной
(или хотя бы поддерживать любые закрытые ее копии обновляемыми по главной копии, и наоборот). Кроме того, доступ к
главной копии переменной должен осуществляться в том порядке, в каком он определен в самой программе.

[Chapter13/Package03/InstanceOf - Продемонстрировать применение операции instanceof](https://github.com/Vladlena2/BookJava2/blob/master/Chapter13/Package03/InstanceOf.java "Посмотреть пример Java")
</details>

<details><summary>Применение операции instanceof</summary>

Иногда тип объекта полезно выяснить во время выполнения. Например, в одном потоке исполнения объекты разных типов могут
формироваться, а в другом потоке исполнения - использоваться. В таком случае удобно выяснить тип каждого объекта,
получаемого в обрабатывающем потоке исполнения. Тип объекта во время выполнения не менее важно выяснить и в том
случае,
когда требуется приведение типов. В языке Java неправильное приведение типов влечет за собой появление ошибок во время
выполнения.

Для разрешения этого вопроса в Java предоставляется операция времени выполнения *instanceof*, которая имеет следующую
общую форму:
```java
ссылка_на_объект instanceof тип
```   
Здесь *ссылка_на_объект* обозначает ссылку на экземпляр класса, а тип - конкретный тип этого класса. Если *
ссылка_на_объект* относится к указанному типу или может быть приведена к нему, то вычисление операции *instanceof*
дает
в итоге логическое значение *true*, а иначе - логическое значение *false*. Таким образом, операция *instanceof* - это
средство, с помощью которого программа может получить сведения об объекте во время выполнения.

</details>

<details><summary>Модификатор доступа strictfp</summary>

Объявляя класс, метод или интерфейс с модификатором доступа *strictfp*, можно гарантировать, что вычисления с плавающей
точкой будут выполняться таким же образом, как и в первых версиях Java. Если класс объявляется с модификатором
доступа *
strictfp*, все его методы автоматически модифицируются как *strictfp*.

Например, в приведенной ниже строке кода компилятору Java сообщается, что во всех методах, определенных в классе
MyClass, следует использовать исходную модель вычислений с плавающей точкой. Откровенно говоря, большинству
программистов вряд ли понадобится модификатор доступа *strictfp*, поскольку он касается лишь небольшой категории
задач.
```java
strictfp class MyClass { // ...
``` 

</details>

<details><summary>Платформенно-ориентированные методы</summary>

Иногда, хотя и редко, возникает потребность вызвать подпрограмму, написанную на другом языке, а не на Java. Как
правило, такая подпрограмма существует
в виде исполняемого кода для ЦП и той среды, в которой приходится работать, т.е. в виде платформенно-ориентированного
кода. Такую подпрограмму, возможно, потребуется вызвать для повышения скорости ее выполнения. С другой стороны, может
возникнуть потребность работать со специализированной сторонней библиотекой, например с пакетом статистических
расчетов.

Для объявления платформенно-ориентированных методов в Java предусмотрено ключевое слово *native*. Однажды объявленные
как *native*, эти методы могут быть вызваны из прикладной программы на Java таким же образом,
как и любой другой метод. Механизм, применяемый для внедрения платформенно-ориентированного кода в прикладные
программы
на Java, называется JNI (*Java Native Interface - платформенно-ориентированный интерфейс Java*).

Чтобы объявить платформенно-ориентированный метод, его имя следует предварить модификатором доступа *native*, но не
определять тело метода, как показано ниже.
```java
public native int meth();
```
Объявив платформенно-ориентированный метод, необходимо написать его и предпринять ряд относительно сложных шагов, чтобы
связать его с кодом Java. Большинство платформенно-ориентированных методов пишутся на С.

</details>

<details><summary>Применение ключевого слова assert</summary>

Ключевое слово *assert* используется на стадии *разработки* программ для создания так называемых утверждений - условий,
которые должны быть *истинными* во время выполнения программы. Если во время выполнения программы условие оказывается
истинным, то никаких действий больше не выполняется. Но если условие окажется ложным, то генерируется исключение
типа *
AssertionError*. Утверждения часто применяются с целью проверить, действительно ли выполняется некоторое ожидаемое
условие. В коде окончательной версии программы утверждения, как правило, отсутствуют.

Ниже приведен пример программы, демонстрирующий применение оператора *assert*. В этом примере проверяется, возвращает
ли метод getnum() положительное значение.

[Chapter13/Package03/AssertDemo - Продемонстрировать применение оператора assert](https://github.com/Vladlena2/BookJava2/blob/master/Chapter13/Package03/AssertDemo.java "Посмотреть пример Java")

Для правильного понимания утверждений очень важно иметь в виду следующее: на них нельзя полагаться для выполнения
каких-нибудь конкретных действий в программе. Дело в том, что отлаженный код окончательной версии программы будет
выполняться с *отключенным* режимом проверки утверждений.

Благодаря утверждениям, строки кода с оператором *assert* можно не удалять из окончательного варианта кода программы.

**Параметры включения и отключения режима проверки утверждений.**

Чтобы *включить* режим проверки утверждений в пакете MyPack, достаточно ввести следующее:
```
-ea:MyPack ...
```

Чтобы *отключить* режим проверки утверждений, следует ввести:
```
-da:MyPack ...
```

Кроме того, класс можно указать с параметром -еа или -da. В качестве примера ниже показано, как включить режим проверки
утверждений отдельно в классе AssertDemo.
```
-ea:AssertDemo
``` 
</details>

<details><summary>Статический импорт</summary>

В языке Java имеется языковое средство, расширяющее возможности ключевого слова import и называемое *статическим
импортом*. Оператор import, предваряемый ключевым словом static, можно применять для импорта статических членов класса
или интерфейса. Благодаря статическому импорту появляется возможность ссылаться на статические члены непосредственно
по
именам, не уточняя их именем класса. Это упрощает и сокращает синтаксис, требующийся для работы со статическими
членами.
```java
// Вычислить длину гипотенузы прямоугольного треугольника
...
// Имена методов уточнены именем их класса Math
hypot = Math.sqrt(Math.pow(sidel, 2) + Math.pow(side2, 2));
...

// Используем статический импортом для доступ к встроенным в Java методам
import static java.lang.Mat.*;

...
// Здесь методы sqrt() и pow() можно вызывать непосредственно, опуская имя их Класса 
hypot = sqrt(pow(sidel, 2) + pow(side2, 2)); 
...

```
*Статический импорт* следует применять на тот случай, если статические члены применяются многократно, в частности при
выполнении целого ряда математических вычислений. В сущности, этим языковым средством стоит пользоваться, но только не
злоупотреблять им.
</details>

<details><summary>Вызов перегружаемых конструкторов по ссылке this()</summary>

Пользуясь *перегружаемыми конструкторами*, иногда удобно вызывать один конструктор из другого. Для этого в Java имеется
еще одна форма ключевого слова this. В общем виде эта форма выглядит следующим образом:
```java
this(список_аргументов)
```
По ссылке this() сначала выполняется *перегружаемый конструктор*, который соответствует заданному *списку_аргументов*,
а затем - любые операторы, находящиеся в теле исходного конструктора, если таковые имеются. Вызов конструктора по
ссылке
this() должен быть *первым* оператором в конструкторе.
Рассмотрим сначала приведенный ниже пример класса, в котором ссылка this() *не употребляется*.

Этот класс содержит три конструктора, каждый из которых инициализирует значения полей а и b. Первому конструктору
передаются отдельные значения для инициализации полей а и b. Второй конструктор принимает только одно значение и
присваивает его обоим полям, а и b. А третий присваивает полям а и b нулевое значение по умолчанию.
```java
class MyClass {
   int a;
   int b;
   // инициализировать поля а и b по отдельности
   MyClass(int i, int j) {
        a = i;
       b = j;    
    }
   // присвоить полям а и b нулевое значение по умолчанию
    MyClass() {
     a = 0;
      b = 0;
    }   
}
```

Используя ссылку this(), приведенный выше класс MyClass можно переписать следующим образом. В данной версии класса
MyClass значения непосредственно присваиваются полям а и b только в конструкторе MyClass (int, int). А два других
конструктора просто вызывают первый конструктор (прямо или косвенно) по ссылке this().
```java
class MyClass {
    int a;
    int b;
    // инициализировать поля а и b по отдельности
   MyClass(int i, int j) {
       a = i;
        b = j;    
    }
    // инициализировать поля а и b одним и тем же значением
   MyClass(int i) {
       this(i, i); // по этой ссылке вызывается конструктор MyClass(i, i);
    }


    // присвоить полям а и b нулевое значение по умолчанию
    MyClass() {
        this(0); // по этой ссылке вызывается конструктор MyClass(O)
  }   
}
```  
Одной из причин, по которой стоит вызывать перегружаемые конструкторы по ссылке this(),служит потребность избежать
дублирования кода. Зачастую сокращение дублированного кода ускоряет загрузку классов, поскольку объектный
код становится компактнее. Это особенно важно для программ, доставляемых через Интернет, когда время их загрузки
критично. Применение ссылки this() позволяет также оптимально структурировать прикладной код, когда конструкторы
содержат большой объем дублированного кода.

Следует также иметь в виду, что вызов очень коротких конструкторов, как, например, из класса MyClass, по ссылке this()
зачастую лишь незначительно увеличивает размер объектного кода. (В некоторых случаях никакого уменьшения объема
объектного кода вообще не происходит.) Дело в том, что байт-код, который устанавливается и возвращается из вызова
конструктора по ссылке this(), добавляет инструкции в объектный файл. Поэтому в таких случаях вызов конструктора по
ссылке this(), несмотря на исключение дублирования кода, не даст значительной экономии времени загрузки, но может
повлечь за собой дополнительные издержки на создание каждого объекта. Поэтому ссылка this() больше всего подходит для
вызова тех конструкторов, которые содержат большой объем кода инициализации, а не тех, которые просто устанавливают значения в нескольких полях.

Вызывая конструкторы по ссылке this(), следует учитывать следующее. Вопервых, при вызове конструктора по ссылке
this() *нельзя* использовать переменные экземпляра класса этого конструктора. И, во-вторых, в одном и том же
конструкторе *нельзя* использовать ссылки super() и this(), поскольку каждая из них должна быть первым оператором в
конструкторе.
</details>

<details><summary>Компактные профили Java API</summary>

В версии JDK 8 внедрено средство, позволяющее организовать подмножества
библиотеки прикладных программных интерфейсов API в так называемые *компактные профили*. Они обозначаются следующим
образом: *compact1, compact2 и cornpactЗ*. Каждый такой профиль содержит подмножество библиотеки. Более того,
компактный
профиль *compact2* включает в себя весь профиль *compact1*, а компактный профиль *compactЗ* - весь профиль *compact2*.
Следовательно, каждый последующий компактный профиль строится на основании предыдущего. Преимущество компактных
профилей
заключается в том, что прикладной
программе не нужно загружать библиотеку полностью. Применение компактных профилей позволяет сократить размер
библиотеки,
а следовательно, выполнять некоторые категории прикладных программ на тех устройствах, где отсутствует полная
поддержка
прикладного программного интерфейса Java API. Благодаря компактным профилям удается также сократить время, требующееся
для загрузки программы. В документации на прикладной программный интерфейс Java API
версии JDK 8 указывается, к какому именно элементу этого прикладного интерфейса принадлежит компактный профиль, если
это
вообще имеет место. Следует, однако, иметь в виду, что в версии JDK 9 на смену компактным профилям пришли внедренные в
ней модули.
</details>

</blockquote>
</details>

<details ГЛАВА 14><summary>ГЛАВА 14. "Обобщения"</summary>

<details><summary>Что такое обобщения</summary>

*Обобщения* - это *параметризованные типы*. Такие типы позволяют объявлять классы, интерфейсы и методы, где тип данных,
которыми они оперируют, указан в виде параметра. Используя обобщения, можно, например, создать единственный класс,
который будет автоматически обращаться с разнотипными данными. Классы, интерфейсы или методы, оперирующие
параметризованными типами, называются *обобщенными*.

Благодаря *обобщениям* все операции приведения типов выполняются автоматически и неявно. Таким образом, обобщения
расширили возможности повторного использования кода, позволив делать это легко и безопасно.

**Простой пример обобщения**

В приведенной ниже программе определяются два класса. Первый из них - *обобщенный* класс Gen, второй - *
демонстрационный* класс GenDemo, в котором используется *обобщенный* класс Gen.

[Chapter14/Package01/GenDemo - Простой обобщенный класс](https://github.com/Vladlena2/BookJava2/blob/master/Chapter14/Package01/GenDemo.java "Посмотреть пример Java")

Обратите внимание на объявление класса Gen в следующей строке кода:
```java
class Gen<T> {
```  
Здесь T обозначает имя параметра типа. Это имя используется в качестве заполнителя, вместо которого в дальнейшем
подставляется имя конкретного типа, передаваемого классу Gen при создании объекта. Это означает, что обозначение T
применяется в классе Gen всякий раз, когда требуется параметр типа. Обратите внимание на то, что обозначение Т
заключено
в угловые скобки ( < > ). Этот синтаксис
может быть обобщен. Всякий раз, когда объявляется параметр типа, он указывается в угловых скобках. В классе Gen
применяется параметр типа, и поэтому он является обобщенным классом, относящимся к так называемому параметризованному
типу.

Далее тип Т используется для объявления объекта оb:
```java
T оb; //объявить объект типа T
```  
Параметр типа Т - это место для *подстановки* конкретного типа, который указывается в дальнейшем при создании объекта
класса Gen. Это означает, что *объект оb станет объектом того типа, который будет передан в качестве параметра типа*
T.
Так, если передать тип String в качестве параметра типа Т, то такой экземпляр объекта оb будет иметь тип String.

Рассмотрим конструктор Gen().
```java
Gen (T o) {
    ob = o;
}
```  
Параметр o имеет тип T. Это означает, что конкретный тип параметра о определяется с помощью параметра типа Т,
передаваемого при создании объекта класса Gen. А поскольку параметр о и переменная экземпляра оЬ относятся к типу T,
то
они получают одинаковый конкретный тип при создании объекта класса Gen.
Параметр типа Т может быть также использован для указания типа, возвращаемого методом, как показано ниже на примере
метода getob(). Объект оb также относится к типу Т, поэтому его тип совместим с типом, возвращаемым методом getob().
```java
T getob() {>
    return оb;
```  
Метод showType() отображает тип Т, вызывая метод getName() для объекта типа Class, возвращаемого в результате вызова
метода getClass() для объекта оЬ. Метод getClass() определен в классе Object, и поэтому он является членом всех
классов.
Этот метод возвращает объект типа Class, соответствующий типу того класса объекта, для которого он вызывается. В
классе
Class определяется метод getName(), возвращающий строковое представление имени класса.

Класс GenDemo служит для демонстрации обобщенного класса Gen. Сначала в нем создается версия класса Gen для целых
чисел, как показано ниже.
```java
Gen<Integer> iOb; 
```  
*Integer* - это аргумент типа, который передается в качестве параметра типа Т из класса Gen. Это объявление фактически
означает создание версии класса Gen, где все ссылки на тип Т преобразуются в ссылки на тип Integer. Таким образом, в
данном объявлении объект оb относится к типу Integer, и метод getob() возвращает тип Integer.

Компилятор Java на самом деле не создает разные версии класса Gen или любого другого обобщенного класса. Вместо этого
компилятор *удаляет* все сведения об обобщенных типах, выполняя необходимые операции приведения типов, чтобы сделать
поведение прикладного кода таким, как будто создана конкретная версия класса Gen. Таким образом, имеется только *одна*
версия класса Gen, которая существует в прикладной программе. Процесс удаления обобщенной информации об обобщенных
типах
называется *стиранием*.

В следующей строке кода переменной iOb присваивается ссылка на экземпляр целочисленной версии класса Gen:
```java
iOb = new Gen<Integer>(12345678);
```  
Когда вызывается конструктор Gen(), аргумент типа Integer также указывается. Это необходимо потому, что объект (в
данном случае - iOb), которому присваивается ссылка, относится к типу Gen<Integer>. Следовательно, ссылка,
возвращаемая
операцией new, также должна относиться
к типу Gen<Integer>. В противном случае во время компиляции возникает ошибка. Например, следующее присваивание вызовет
ошибку во время компиляции:
```java
iOb = new Gen<DouЬle>(12345678.0); // ОШИБКА!!!
```  
Переменная iOb относится к типу Gen<Integer>, поэтому она не может быть использована для присваивания ссылки типа
Gen<DouЬle>. Такая проверка типа является одним из основных преимуществ обобщений, потому что она обеспечивает типовую
безопасность.

Как следует из комментариев к данной программе, в приведенной ниже операции присваивания выполняется автоупаковка для
инкапсуляции значения 12345678 типа int в объекте типа Integer.
```java
iOb = new Gen<Integer>(12345678);
```  
*Обобщение* Gen<Integer> создает конструктор, принимающий аргумент типа Integer. А поскольку предполагается объект типа
Integer, то значение 12345678 автоматически упаковывается в этом объекте. Присваивание может быть указано и явным
образом, как показано ниже, но такой его вариант не дает никаких преимуществ.
```java
iOb = new Gen<Integer>(new Integer(12345678));
```  
Затем в данной программе отображается тип объекта оb в переменной iOb (в данном случае - тип Integer). А далее
получается значение объекта оb в следующей строке кода:
```java
int v = iOb.getob();
```  
Метод getob() возвращает обобщенный тип T, который был заменен на тип Integer при объявлении переменной экземпляра iOb.
Поэтому метод getob() также возвращает тип Integer, который автоматически распаковывается в тип
int и присваивается переменной v типа int. Следовательно, тип, возвращаемый методом getob(), не нужно приводить к типу
Integer. Безусловно, выполнять автоупаковку необязательно, переписав предыдущую строку кода так, как показано ниже. Но
автоупаковка позволяет сделать код более компактным.
```java
int v = iOb.getob().intValue();
```  
Далее в классе GenDemo объявляется объект типа Gen<String> следующим образом:
```java
Gen<String> sOb = new Gen<String>("текстовая строка");
```  
В качестве аргумента типа в данном случае указывается тип String, подставляемый вместо параметра типа Т в обобщенном
классе Gen. Это, по существу, приводит к созданию строковой версии класса Gen, что и демонстрируется в остальной части
программы.

</details>

<details><summary>Обобщения оперируют только ссылочными типами</summary>

Когда объявляется экземпляр *обобщенного типа*, аргумент, передаваемый в качестве *параметра типа*, должен относиться
к *ссылочному типу*, но ни в коем случае не к примитивному типу вроде int или char. Например, в качестве параметра T
классу Gen можно передать *тип любого класса*, но нельзя передать примитивный тип.

Безусловно, отсутствие возможности использовать *примитивный тип* не является серьезным ограничением, поскольку можно
применять *оболочки типов данных* (как это делалось в предыдущем примере программы) для инкапсуляции примитивных
типов.
Более того, механизм автоупаковки и автораспаковки в Java делает прозрачным применение оболочек типов данных.
</details>

<details><summary>Обобщенные типы различаются по аргументам типа</summary>

В отношении обобщенных типов самое главное понять, что ссылка на одну конкретную версию обобщенного типа несовместима с
другой версией того же самого обобщенного типа. Так, если ввести следующую строку кода в предыдущую программу, то при
ее
компиляции возникнет ошибка:
```java
iOb = sOb; // НЕВЕРНО!!!
```  
Несмотря на то что переменные экземпляра iOb и sOb относятся к типу Gen<T>, они являются *ссылками на разные типы
объектов*, потому что их параметры типов отличаются. Этим, в частности, обобщения обеспечивают типовую безопасность,
предотвращая подобного рода ошибки.
</details>

<details><summary>Каким образом обобщения повышают типовую безопасность</summary>

Дело в том, что обобщения *автоматически* гарантируют типовую безопасность во всех операциях, где задействован
обобщенный класс Gen. В процессе его применения исключается потребность в явном приведении и ручной проверке типов в
прикладном коде.  
Пример программы, в которой создается *необобщенный* эквивалент класса Gen:

[Chapter14/Package02/NonGenDemo - Продемонстрировать необобщенный класс](https://github.com/Vladlena2/BookJava2/blob/master/Chapter14/Package02/NonGenDemo.java "Посмотреть пример Java")

В классе NonGen все ссылки на тип Т заменены ссылками на тип Object. Это позволяет хранить в классе NonGen объекты
любого типа, как и в обобщенном классе Gen. Но это не позволяет компилятору Java получить какиенибудь подлинные
сведения
о типе данных, фактически сохраняемых в объекте
класса NonGen, что плохо по двум причинам. Во-первых, для извлечения сохраненных данных требуется явное приведение
типов. И во-вторых, многие ошибки несоответствия типов не могут быть обнаружены до времени выполнения.

Обратим внимание на следующую строку кода:
```java
int v = (Integer) iOb.getob();
```
Метод getob() возвращает тип Object, поэтому его нужно привести к типу Integer, чтобы выполнить автораспаковку и
сохранить значение в переменной v. Если убрать приведение типов, программа не скомпилируется. Если в ее версии с
обобщениями приведение типов производится неявно, то в версии без обобщений приведение должно быть сделано явно. Это
не
только неудобно, но и служит потенциальным источником ошибок.

Теперь рассмотрим следующий фрагмент кода в конце данной программы:
```java
// Этот код компилируется, но он принципиально неверный!!!
iOb = sOb;
v = (Integer) iOb.getOb(); // Ошибка!!! во время выполнения.
```
Здесь переменной экземпляра iOb присваивается значение переменной экземпляра sOb. Но переменная экземпляра sOb
ссылается на объект, содержащий символьную строку, а не целое число. Такое присваивание синтаксически корректно,
потому
что все ссылки типа NonGen одинаковы и любая ссылка типа NonGen
может указывать на любой другой объект типа NonGen. Но семантически эта операция присваивания неверна, что и отражено
в
следующей строке коде. Здесь тип, возвращаемый методом getob(),приводится к типу Integer, а затем делается попытка
присвоить полученное значение переменной v. Дело в том, что переменная экземпляра iOb теперь ссылается на объект,
хранящий данные типа String, а не Integer.  
К сожалению, без обобщений компилятор Java просто не в состоянии обнаружить эту ошибку. Вместо этого во время
выполнения генерируется исключение при попытке привести к типу Integer.

Возможность создавать *типизированный* (т.е. обеспечивающий типовую безопасность) код, в котором ошибки несоответствия
типов перехватываются *компилятором*, является главным преимуществом обобщений.

Благодаря *обобщениям* ошибки, возникающие во время выполнения, преобразуются в ошибки, обнаруживаемые во время
компиляции. В этом и заключается главное преимущество обобщений.
</details>

<details><summary>Обобщенный класс с двумя параметрами типа</summary>

Для обобщенного типа можно объявлять не только один параметр. Несколько *параметров типа* можно указать списком через
запятую. Например, приведенный ниже класс TwoGen является переделанным вариантом класса Gen, принимающим два параметра
типа.

[Chapter14/Package03/TwoGenDemo - Продемонстрировать применение класса ТwoGen](https://github.com/Vladlena2/BookJava2/blob/master/Chapter14/Package03/TwoGenDemo.java "Посмотреть пример Java")
</details>

<details><summary>Общая форма обобщенного класса</summary>

Синтаксис, представленный в предыдущих примерах программ, может быть обобщен. Ниже показано, как выглядит синтаксис
объявления обобщенного класса.
```
  class имя_класса<список_параметров_типа> { // ...
```  
А синтаксис объявления ссылки на обобщенный класс и создание его экземпляра полностью выглядит следующим образом:
```
имя_класса<список_аргументов_типа> имя_переменной
new имя_класса<список_аргументов_типа>  
(список_аргументов_констант); 
```
</details>

<details><summary>Ограниченные типы</summary>

Допустим, что требуется создать обобщенный класс с методом, возвращающим среднее значение массива чисел. С помощью
этого класса требуется получить среднее значение из целых чисел, а также чисел с плавающей точкой одинарной и двойной
точности. Таким образом, тип числовых данных требуется указать обобщенно, используя параметр типа.

Для подобных случаев в Java предоставляются *ограниченные типы*. Указывая параметр типа, можно наложить *ограничение* в
виде верхней границы, где объявляется суперкласс, от которого должны быть унаследованы все аргументы типов.
С этой целью вместе с параметром указывается ключевое слово *extends*:
```java
<Т extends суперкласс>
```  
Это означает, что параметр типа T может быть заменен только указанным *суперклассом* или его подклассами.
Следовательно, *суперкласс* объявляет верхнюю границу включительно.

[Chapter14/Package04/StatsDemo - Продемонстрировать ограничение параметра типа](https://github.com/Vladlena2/BookJava2/blob/master/Chapter14/Package04/StatsDemo.java "Посмотреть пример Java")
</details>

<details><summary>Применение метасимвольных аргументов</summary>

*Метасимвольный аргумент* обозначается знаком **"?"** и представляет *неизвестный* тип.

Например, в классе Stats, рассмотренном в предыдущем разделе, предполагается, что в него требуется ввести метод
sameAvg(), где определяется, содержат ли два объекта типа Stats массивы, дающие *одинаковое среднее значение*
независимо
от типа числовых значений в них. Так, если один объект содержит значения 1.0, 2.0 и 3.0 типа *doublе*, а другой - *
целочисленные* значения 1, 2 и 3, то их *среднее значение будет одинаковым*.

Применяя метасимвольный аргумент, метод sameAvg() можно написать, следующим образом:
```java
// Обратите внимание на применение метасимвола постановки
boolean sameAvg(Stats<?> ob) {
   if (average() == ob.average())
       return true;
  return false;
}
```
Здесь *метасимвольный* аргумент типа Stats<?> совпадает с любым объектом класса Stats, что позволяет сравнивать средние
значения любых двух объектов класса Stаts.

[Chapter14/Package05/WildcardDemo - Продемонстрировать применение метасимволов подстановки в качестве аргументов](https://github.com/Vladlena2/BookJava2/blob/master/Chapter14/Package05/WildcardDemo.java "Посмотреть пример Java")
</details>

<details><summary>Ограниченные метасимвольные аргументы</summary>

*Ограниченный* метасимвол подстановки задает верхнюю или нижнюю границу для аргумента типа. Это позволяет ограничить
типы объектов, которыми будет оперировать метод. Наиболее распространен метасимвол, который налагает ограничение
сверху
и создается с помощью оператора *extends* почти так же, как и ограниченный тип.

В общем, чтобы установить верхнюю границу для метасимвола, следует воспользоваться приведенной ниже формой
метасимвольного выражения:
```java
<? extends суперкласс>
```
Здесь *суперкласс* обозначает имя класса, который служит верхней границей. Не следует забывать, что это включающее
выражение, а следовательно, класс, заданный в качестве верхней границы (т.е. суперкласс), также находится в пределах
допустимых типов.

Имеется также возможность указать нижнюю границу для метасимвольного аргумента, введя оператор *super* в его
объявление. Ниже приведена общая форма ограничения метасимвольного аргумента снизу.
```java
<? super подкласс>
```
В данном случае допустимыми аргументами могут быть только те классы, которые являются суперклассами для указанного *
подкласса*. Это исключающее выражение, поскольку оно не включает в себя заданный *подкласс*.

[Chapter14/Package05/BoundedWildcard - Продемонстрировать Ограниченные метасимвольные аргументы](https://github.com/Vladlena2/BookJava2/blob/master/Chapter14/Package05/BoundedWildcard.java "Посмотреть пример Java")
</details>

<details><summary>Создание обобщенного метода</summary>

Рассмотрим объявление обобщенного метода isIn() в следующей строке кода:
```java
static <T extends Comparable<T>, V extends T>
   boolean isIn(T x, V[] y) {
}
```
Параметр типа объявляется *до* типа, возвращаемого методом. Тип T расширяет обобщенный тип *Comparable<T>*, где *
Comparable* - это интерфейс, объявляемый в пакете java.lang. В классе, реализующем интерфейс *Comparable*,
определяются
объекты, которые могут быть упорядочены. Следовательно, указание интерфейса *Comparable* в качестве верхней границы
гарантирует, что метод *isIn()* вполне применим к объектам, которые можно сравнивать. Интерфейс *Comparable* является
обобщенным, а параметр его типа обозначает тип сравниваемых объектов.

[Chapter14/Package06/GenMethDemo - Продемонстрировать простой обобщенный метод](https://github.com/Vladlena2/BookJava2/blob/master/Chapter14/Package06/GenMethDemo.java "Посмотреть пример Java")
</details>

<details><summary>Обобщенные конструкторы</summary>

Конструкторы также могут быть *обобщенными*, даже если их классы таковыми не являются.

[Chapter14/Package06/GenConsDemo - Использовать обобщенный конструктор](https://github.com/Vladlena2/BookJava2/blob/master/Chapter14/Package06/GenConsDemo.java "Посмотреть пример Java")

В конструкторе GenCons() задается параметр обобщенного типа, который может быть производным от класса Number, поэтому
конструктор GenCons() можно вызывать с любым числовым типом, включая Integer, Float или Double.
Несмотря на то, что класс GenCons не является обобщенным, его конструктор обобщен.
</details>

<details><summary>Обобщенные интерфейсы</summary>

Обобщенные интерфейсы объявляются таким же образом, как и обобщенные классы.
Общая синтаксическая форма обобщенного интерфейса.
```java
interface имя_интерфейса<список_параметров_типа> { // ... 
```
Здесь *список_параметров_типа* обозначает разделяемый запятыми список параметров типа. Когда *реализуется* обобщенный
интерфейс, следует указать аргументы типа.
```java
class имя_класса<список_параметров_типа>
      implements имя_интерфейса<список_аргументов_типа> ( 
```

Далее в приведенном примере, создается обобщенный интерфейс MinMax, где объявляются методы min() и max(), которые, как
предполагается, должны возвращать минимальное и максимальное значения из некоторого множества объектов.

Объявление обобщенного интерфейса MinMax:
```java
interface MinMax<T extends Comparable<T>> {
}
```
Параметр типа T ограничивается сверху интерфейсом Comparable. Интерфейс Comparable определен в пакете java.lang для
сравнения объектов. Параметр его типа обозначает тип сравниваемых объектов.

Далее интерфейс MinMax реализуется в классе ClassMinMax:
```java
class ClassMinMax<T extends Comparable<T>> implements MinMax<T> {
}
```
Параметр типа T сначала объявляется в классе MyClass, а затем передается интерфейсу MinMax. Интерфейсу MinMax требуется
тип класса, реализующего интерфейс Comparable, поэтому в объявлении класса, реализующего этот интерфейс (в данном
случае
- класса ClassMinMax), должно быть наложено такое же ограничение.
   Следовательно, однажды наложенное ограничение уже не нужно повторять в операторе implements.

[Chapter14/Package06/GenIFDemo - Пример применения обобщенного интерфейса](https://github.com/Vladlena2/BookJava2/blob/master/Chapter14/Package06/GenIFDemo.java "Посмотреть пример Java")

**Обобщенный интерфейс дает два преимущества:**  
*Во-первых*, он может быть реализован для разных типов данных.  
*Во-вторых*, он позволяет наложить ограничения на типы данных, для которых он может быть реализован.

</details>

<details><summary>Иерархии обобщенных классов</summary>

*Обобщенные* классы могут быть частью иерархии классов, как и любые другие *необобщенные* классы. Это означает, что
обобщенный класс может действовать в качестве суперкласса или подкласса. Главное отличие *обобщенных* иерархий
от *необобщенных* состоит в том, что в *обобщенной* иерархии любые аргументы типа, требующиеся обобщенному *
суперклассу*
, должны передаваться всеми *подклассами* вверх по иерархии. Это похоже на порядок передачи аргументов конструкторам
вверх по иерархии.

**Применение обобщенного суперкласса**

Приведем пример иерархии, в которой применяется обобщенный суперкласс.
```java
// Простая иерархия обобщенных классов
class Gen<T> {
  Т оb;
 
  Gen (Т о) {
     оb = о;
  }
  
  // возвратить объект оb
 T getOb() {
     return оb;
  }
}
// Подкласс, производный от класса Gen
class Gen2<T> extends Gen<T> {
  Gen2 (Т о) {
     super (о);
   }
}
```
В этой иерархии класс *Gen2* расширяет обобщенный класс *Gen*. Обратите внимание на объявление класса *Gen2* в
следующей строке кода:
```java
class Gen2<T> extends Gen<T> {
```
Параметр типа *T* указан в объявлении класса *Gen2* и передается классу *Gen* в выражении *extends*. Это означает, что
тип, передаваемый классу *Gen2*, будет также *передан* классу *Gen*. Например, в объявлении
```java
Gen2<Integer> num = new Gen2<Integer>(100);
```
тип *Integer* передается в качестве параметра типа классу *Gen*. Таким образом, объект *оb* в части *Gen* класса *Gen2*
будет иметь тип *Integer*.
Следует также иметь в виду, что параметр типа *T* используется в классе *Gen2* только для поддержки его суперкласса *
Gen*. Даже если *подкласс* обобщенного суперкласса не должен быть обобщенным, в нем все равно должны быть указаны
параметры типа, требующиеся его обобщенному *суперклассу*.
Если требуется, то *подкласс* может быть дополнен и своими параметрами типа.

[Chapter14/Package07/HierDemo - Пример обобщенного суперкласса и подкласса со своим параметром](https://github.com/Vladlena2/BookJava2/blob/master/Chapter14/Package07/HierDemo.java "Посмотреть пример Java")
</details>

<details><summary>Обобщенный подкласс</summary>

*Суперклассом* для *обобщенного* класса вполне может служить и *необобщенный* класс.  
В качестве примера представлена следующая программа:

[Chapter14/Package08/HierDemo2 - Пример обобщенного суперкласса и подкласса со своим параметром](https://github.com/Vladlena2/BookJava2/blob/master/Chapter14/Package08/HierDemo2.java "Посмотреть пример Java")
</details>

<details><summary>Сравнение типов в обобщенной иерархии во время выполнения</summary>

Для получения сведений о типе во время выполнения служит оператор *instanceof*.  
Оператор instanceof определяет, является ли объект экземпляром класса. Он возвращает логическое значение true, если
объект относится к указанному типу или может быть приведен к этому типу. Оператор i ns t anc ео f можно применять к
объектам обобщенных классов.  
В примере класса демонстрируются некоторые последствия совместимости типов в обобщенных иерархиях:

[Chapter14/Package09/HierDemo3 - Использовать оператор instanceof в иерархии обобщенных классов](https://github.com/Vladlena2/BookJava2/blob/master/Chapter14/Package09/HierDemo3.java "Посмотреть пример Java")

**Приведение типов**

Тип одного экземпляра обобщенного класса можно привести к другому только в том случае, если они совместимы и их
аргументы типа одинаковы. Например, следующее приведение типов из предыдущего примера программы:
```java
    (Gen<Integer>) iOb2 // допустимо
```
вполне допустимо, потому что объект iОb2 является экземпляром типа Gen<Integer>. А следующее приведение типов:
```java
   (Gen<Long>) iOb2 //недопустимо
```  
недопустимо, поскольку объект iOb2 не является экземпляром типа Gen<Long>.
</details>

<details><summary>Переопределение методов в обобщенном классе</summary>

Метод из обобщенного класса может быть переопределен, как и любой другой метод.

[Chapter14/Package10/OverrideGenMeth - Переопределение обобщенного метода в обобщенном классе](https://github.com/Vladlena2/BookJava2/blob/master/Chapter14/Package10/OverrideGenMeth.java "Посмотреть пример Java")
</details>

<details><summary>Выведение типов и обобщения</summary>

В версии JDK 7 был внедрен синтаксический элемент, позволяющий избежать повторного указания аргументов типа.
```java
    MyClass<lnteger, String> mcOb = new MyClass<>(99, "Строка");
```
Обратите внимание на то, что в правой части приведенного выше оператора, где создается экземпляр, просто указываются
угловые скобки(<>), обозначающие пустой список аргументов типа и называемые ромбовидным оператором. Этот оператор
предписывает компилятору вывести тип аргументов, требующихся конструктору в операции new. Главное преимущество
синтаксиса выведения типов заключается в том, что он короче и иногда значительно сокращает очень длинные операторы
объявления.

Когда выполняется выведение типов, синтаксис объявления для обобщенной ссылки и создания экземпляра имеет приведенную
ниже общую форму, где список аргументов типа конструктора в операции new пуст.
```
   имя_класса<список_аргументов_типа> имя_переменной = new имя_класса<>(список_аргументов_конструктора);
```
Выведение типов можно также выполнять и при передаче параметров. Так, если в класс MyClass вводится следующий метод:
```java
boolean isSame(MyClass<T, V> о) {
    if(ob1 == о.оb1 && оb2 == о.оb2) return true;
    else return false; 
```
то приведенный ниже вызов считается вполне допустимым.
```java
if(mcOb.isSame(new MyClass<>(88, "test")))
   System.out.println("Same");
```
В данном случае аргументы типа для аргумента, передаваемого методу isSame(), могут быть выведены из параметров типа.
</details>

</details>

<details ГЛАВА 15><summary>ГЛАВА 15. "Лямбда-выражения"</summary>
<blockquote>

<details><summary>Введение в лямбда-выражения</summary>

Особое значение для ясного представления о том, каким образом лямбда-выражения реализованы в Java, имеют две языковые
конструкции. Первой из них является само лямбда-выражение, а второй - функциональный интерфейс. Начнем
с простого определения каждой из этих конструкций.

_Лямбда-выражение_, по существу, является анонимным (т.е. безымянным) методом. Но этот метод не выполняется
самостоятельно, а служит для реализации
метода, определяемого в функциональном интерфейсе. Таким образом, лямбдавыражение приводит к некоторой форме анонимного
класса. Нередко лямбда-выражения называют также замыканиями.

_Функциональным_ называется такой интерфейс, который содержит один
и только один абстрактный метод. Как правило, в таком методе определяется
предполагаемое назначение интерфейса. Следовательно, функциональный интерфейс представляет единственное действие.
Например, стандартный интерфейс
_Runnable_ является функциональным, поскольку в нем определяется единственный метод _run()_, который, в свою очередь,
определяет действие самого интерфейса _Runnable_.
Кроме того, в функциональном интерфейсе определяется целевой тип лямбда-выражения. В связи с этим необходимо подчеркнуть
следующее: лямбда-выражение можно использовать
только в том контексте, в котором определен его целевой тип. И еще одно замечание: функциональный интерфейс
иногда еще называют SАМ-типом, где сокращение SAM обозначает _Single Abstract Method - единственный абстрактный метод_.

---
**На заметку** В функциональном интерфейсе можно определить любой открытый метод, определенный в классе Object, например метод equals() , 
не воздействуя на состояние его функционального интерфейса. Открытые методы из класса Object считаются неявными членами
функционального интерфейса, поскольку они автоматически реализуются экземпляром функционального интерфейса.

</details>

<details><summary>Основные положения о лямбда-выражениях</summary>

_Лямбда-выражение_ вносит новый элемент в синтаксис и операцию в язык Java.
Эта новая операция называется лямбда-операц,ией или операцией-стрелкой ( - > ).
Она разделяет лямбда-выражение на две части. В левой части указываются любые
параметры, требующиеся в лямбда-выражении. (Если же параметры не требуются, то они указываются пустым списком.) А в правой части находится тело лямбда-выражения, где определяются действия, выполняемые лямбда-выражением.
Операция ( - > ) буквально означает "становиться" или "переходить".

В языке Java определены две разновидности тел лямбда-выражений. Одна из
них состоит из единственного выражения, а другая - из блока кода. Рассмотрим
сначала лямбда-выражения, в теле которых определяется единственное выражение. А лямбда-выражения с блочными телами мы обсудим далее в этой главе.

Прежде чем продолжить, обратимся к некоторым примерам лямбда-выражений. Рассмотрим сначала самое простое лямбда-выражение, какое только можно
написать. В приведенном ниже лямбда-выражении вычисляется значение константы.

    () -> 123.45

Это лямбда-выражение не принимает никаких параметров, т.е. список его параметров оказывается пустым. Оно возвращает
значение константы 123.45.
Следовательно, это выражение аналогично вызову следующего метода:

    double myMeth() {
        eturn 123.45
    }

Разумеется, метод, определяемый лямбда-выражением, не имеет имени. Ниже приведено более интересное лямбда-выражение.
    
    () -> Math.random() * 100

В этом лямбда-выражении из метода Math. random () получается псевдослучайное значение, которое умножается на 100, и затем возвращается результат. И
это лямбда-выражение не требует параметров. Если же лямбда-выражению требуются параметры, они указываются списком в левой части лямбда-операции. Ниже
приведен простой пример лямбда-выражения с одним параметром.
    
    (n) -> (n % 2)==0

Это выражение возвращает логическое значение true, если числовое значение
параметра n оказывается четным. Тип параметра (в данном случае n) можно указывать явно, но зачастую в этом нет никакой нужды, поскольку его тип в большинстве случаев выводится. Как и в именованном методе, в лямбда-выражении можно
указывать столько параметров, сколько требуется.

</details>

<details><summary>Функциональные интерфейсы</summary>

Как пояснялось ранее, функциональным называется такой интерфейс, в котором определяется единственный абстрактный метод. Те, у кого имеется предыдущий опыт программирования на Java, могут возразить, что все методы интерфейса
неявно считаются абстрактными, но так было до внедрения лямбда-выражений.
Как пояснялось в главе 9, начиная с версии JDK 8, для метода, объявляемого в интерфейсе, можно определить стандартное поведение по умолчанию, и поэтому
он называется методом с реал.изац,ией по умолчанию. Отныне метод интерфейса считается абстрактным лишь в том случае, если у него отсутствует реализация
по умолчанию. А поскольку нестатические, незакрытые и не реализуемые по умолчанию методы интерфейса неявно считаются абстрактными, то их не обязательно
объявлять с модификатором доступа abstract, хотя это и можно сделать при желании.

Ниже приведен пример объявления функционального интерфейса.

    interface MyNumber {
        double getValue();
    }

В данном примере метод getValue() неявно считается абстрактным и единственным, определяемым в интерфейсе MyNumber. Следовательно, интерфейс
MyNumber является функциональным, а его функция определяется методом getValue().


Как упоминалось ранее, лямбда-выражение не выполняется самостоятельно,
а скорее образует реализацию абстрактного метода, определенного в функциональном интерфейсе, где указывается его целевой тип. Таким образом, лямбдавыражение может быть указано только в том контексте, в котором определен его
целевой тип. Один из таких контекстов создается в том случае, когда лямбда-выражение присваивается ссылке на функциональный интерфейс. К числу других контекстов целевого типа относятся инициализация переменных, операторы return и аргументы методов.

Рассмотрим пример, демонстрирующий применение лямбда-выражения в контексте присваивания. С этой целью сначала объявляется ссылка на функциональный интерфейс MyNurnber, как показано ниже.

    // создать ссылку на функциональный интерфейс MyNumber
    MyNumber myNum;

Затем лямбда-выражение присваивается этой ссылке на функциональный интерфейс следующим образом:

    // использовать лямбда-выражение в контексте присваивания
    myNum = () -> 123.45;

Когда лямбда-выражение появляется в контексте своего целевого типа, автоматически создается экземпляр класса,
реализующего функциональный интерфейс, причем лямбда-выражение определяет поведение абстрактного метода, объявляемого в
функциональном интерфейсе. А когда этот метод вызывается через свой адресат, выполняется лямбда-выражение. Таким
образом, лямбда-выражение позволяет преобразовать сегмент кода в объект.

В предыдущем примере лямбда-выражение становится реализацией метода getValue(). В итоге получается значение константы
123.45, которое выводится на экран следующим образом:

    // вызвать метод getValue(), реализуемый присвоенным ранее лямбда-выражением
    System.out.println(myNum.getValue());

Лямбда-выражение было ранее присвоено переменной rnyNurn ссылки на функциональный интерфейс MyNurnber. Оно возвращает значение константы 123. 45,
которое получается в результате вызова метода getValue ().

Чтобы лямбда-выражение использовалось в контексте своего целевого типа,
абстрактный метод и лямбда-выражение должны быть совместимыми по типу. Так,
если в абстрактном методе указываются два параметра типа int, то и в лямбдавыражении должны быть указаны два параметра, тип которых явно обозначается
как int или неявно выводится как int из самого контекста. В общем, параметры
лямбда-выражения должны быть совместимы по типу и количеству с параметрами
абстрактного метода. Это же относится и к возвращаемым типам. А любые исключения, генерируемые в лямбда-выражении, должны быть приемлемы для абстрактного метода.

```java
/**
 * В данном примере метод getValue() неявно считается абстрактным
 * и единственным, определяемым в интерфейсе MyNumber.
 * Следовательно, интерфейс MyNumber является функциональным,
 * а его функция определяется методом getValue().
 */
public interface MyNumber {
    double getValue();
}

public class LambdaMyNumber {
    public static void main(String[] args) {
        // создать ссылку на функциональный интерфейс MyNumber
        MyNumber myNumber;

        // использовать лямбда-выражение в контексте присваивания
        myNumber = () -> 123.45;

        System.out.println(myNumber.getValue());
    }
}

```
</details>

<details><summary>Некоторые примеры лямбда-выражений</summary>

Принимая во внимание все сказанное выше, рассмотрим ряд простых примеров, демонстрирующих основные принципы действия лямбда-выражений. В первом примере программы все приведенные ранее фрагменты кода собраны в единое целое:

```java
package Chapter15.Package01;

//Продемонстрировать применение простого лямбда-выражения

//Функциональный интерфейс
interface MyNumber {
    double getValue();
}

class LambdaDemo {
    public static void main(String[] args) {
        MyNumber myNum; // объявить ссылку на функциональный интерфейс

        // Здесь лямбда-выражение просто является константным выражением.
        // Когда оно присваивается ссылочной переменной myNum, получается экземпляр
        // класса, в котором лямбда-выражение реализует метод getValue() из
        // функционального интерфейса MyNumber
        myNum = () -> 123.45;

        // вызвать метод getValue(), предоставляемый присвоенным ранее лямбда-выражением
        System.out.println("Фикcиpoвaннoe значение: " + myNum.getValue());

        // здесь используется более сложное выражение
        myNum = () -> Math.random() * 100;

        // вызываем лямбда-выражение из предыдущей строки кода
        System.out.println("Cлyчaйнoe значение: " + myNum.getValue());
        System.out.println("Другое слyчaйнoe значение: " + myNum.getValue());

        // Лямбда-выражение должно быть совместимо по типу данных с абстрактным методом,
        // определяемым в функциональном интерфейсе.

        // Эта строка кода ошибочна !!!
        // myNum = () -> "132.33";
    }
}
/* ------------------------------------------
Фикcиpoвaннoe значение: 123.45
Cлyчaйнoe значение: 15.56917743235875
Другое слyчaйнoe значение: 54.974359374708946
 */
```

[Chapter15/Package01/LambdaDemo - Пример простого лямбда-выражения](./Chapter15/Package01/LambdaDemo.java "Посмотреть пример Java")

Как упоминалось ранее, лямбда-выражение должно быть совместимо по типу данных с абстрактным методом, для реализации которого оно предназначено.

Именно поэтому последняя строка кода в приведенном выше примере закомментирована. Ведь значение типа String несовместимо с типом double, возвращаемым методом getValue().

```java

package Chapter15.Package01;

// Продемонстрировать применение лямбда-выражения,
// принимающего один параметр
// Еще один функциональный интерфейс
interface NumericTest {
boolean test(int n);
}

public class LambdaDemo2 {
public static void main(String[] args) {
// Лямбда-выражение, в котором проверяется,
// является ли число четным
NumericTest isEven = (n) -> (n % 2) == 0;

        if (isEven.test(10))
            System.out.println("Чиcлo 10 четное");
        if (!isEven.test(9))
            System.out.println("Чиcлo 9 нечетное");

        // А теперь воспользуемся лямбда-выражением,
        // в котором проверяется, является ли число
        // неотрицательным
        NumericTest isNonNeg = (n) -> n >= 0;

        if (isNonNeg.test(1))
            System.out.println("Чиcлo 1 неотрицательное");
        if (!isNonNeg.test(-1))
            System.out.println("Чиcлo -1 отрицательное");
    }
}

/* --------------------
Чиcлo 10 четное
Чиcлo 9 нечетное
Чиcлo 1 неотрицательное
Чиcлo -1 отрицательное
*/
```
[Chapter15/Package01/LambdaDemo2 - Пример простого лямбда-выражения](./Chapter15/Package01/LambdaDemo2.java "Посмотреть пример Java")

</details>

<details><summary>Блочные лямбда-выражения</summary>

Блочное лямбда-выражение расширяет те виды операций, которые могут выполняться в лямбда-выражении, поскольку оно
допускает в своем теле наличие нескольких операторов. Например, в блочном лямбда-выражении можно объявлять переменные,
организовывать циклы, указывать операторы выбора if и switch, создавать вложенные блоки и т.д.

Пример программы, где блочное Лямбда-выражение применяется для вычисления и возврата факториала целочисленного
значения.
В данном примере программы на то, что в блочном лямбдавыражении объявляется переменная *result*, организуется цикл *
for* и указывается оператор *return*. Все эти действия вполне допустимы в теле блочного лямбдавыражения. По существу,
тело блока такого выражения аналогично телу метода. Следует также иметь в виду, что когда в лямбда-выражении оказывается
оператор *return*, он просто вызывает возврат из самого лямбда-выражения, но не из объемлющего его метода.

[Chapter15/Package02/FactorialUsingLambda - Определение ФАКТОРИАЛА используя Лямбда-выражение](https://github.com/Vladlena2/BookJava2/blob/master/Chapter15/Package02/FactorialUsingLambda.java "Посмотреть пример Java")

В следующем примере программы, блочное Лямбда-выражение изменяет строку на обратный порядок следования символов в этой
строке.
В функциональном интерфейсе *StringFunc* объявляется метод *getReversal()*, принимающий параметр типа *String* и
возвращающий значение типа *String*. Следовательно, в лямбда-выражении *reverse* тип параметра *(str)* должен быть
выведен как *String*. Метод *charAt()* вызывается для параметра *(str)*, как для объекта типа *String*. Это вполне
допустимо, поскольку тип String этого параметра выводится автоматически.

[Chapter15/Package02/StringReversalLambda - Развернуть строку в обратном порядке (используя Лямбда-выражение)](https://github.com/Vladlena2/BookJava2/blob/master/Chapter15/Package02/StringReversalLambda.java "Посмотреть пример Java")

</details>

<details><summary>Обобщенные функциональные интерфейсы</summary>

Указывать параметры типа в самом лямбда-выражении нельзя. Следовательно, лямбда-выражение не может быть обобщенным.

Вместо того чтобы объявлять два функциональных интерфейса, методы которых отличаются только типом данных, можно
объявить один обобщенный интерфейс, который можно использовать в обоих случаях. А вот функциональный интерфейс,
связанный с лямбда-выражением, может быть обобщенным. В этом случае целевой тип лямбда-выражения отчасти определяется
аргументом типа или теми аргументами, которые указываются при объявлении ссылки на функциональный интерфейс.

Чтобы не объявлять два функциональных интерфейса, методы которых отличаются только типом данных, можно объявить *один
обобщенный интерфейс*, который можно использовать в обоих случаях.

[Chapter15/Package03/GenericFunctionalinterfaceDemo - Пример обобщенного функционального интерфейса с разнотипными Лямбда-выражениями](https://github.com/Vladlena2/BookJava2/blob/master/Chapter15/Package03/GenericFunctionalinterfaceDemo.java "Посмотреть пример Java")
</details>

<details><summary>Передача лямбда-выражений в качестве аргументов</summary>

Для передачи лямбда-выражения в качестве аргумента параметр, получающий это выражение в качестве аргумента, должен
иметь тип функционального интерфейса, совместимого с этим лямбда-выражением.

[Chapter15/Package04/LambdasAsArgumentsDemo - Передать лямбда-выражение в качестве аргумента вызываемому методу](https://github.com/Vladlena2/BookJava2/blob/master/Chapter15/Package04/LambdasAsArgumentsDemo.java "Посмотреть пример Java")
</details>

<details><summary>Лямбда-выражения и исключения</summary>

Лямбда-выражение может генерировать исключение. Если оно генерирует проверяемое исключение, то последнее должно быть
совместимо с исключениями, перечисленными в выражении throws из объявления абстрактного метода в функциональном
интерфейсе.

[Chapter15/Package05/LambdaExceptionDemo - Сгенерировать исключение из лямбда-выражения](https://github.com/Vladlena2/BookJava2/blob/master/Chapter15/Package05/LambdaExceptionDemo.java "Посмотреть пример Java")
</details>

<details><summary>Лямбда-выражения и захват переменных</summary>

Если в лямбда-выражении используется локальная переменная из объемлющей его области видимости, то возникает особый
случай, называемый *захватом переменной*.  
В этом случае в лямбда-выражении можно использовать только те локальные переменные, которые действительно являются
конечными. Действительно конечной считается такая переменная, значение которой не изменяется после ее первого
присваивания. Такую переменную совсем не обязательно объявлять как final, хотя это и не считается ошибкой. (Параметр
this в объемлющей области видимости автоматически оказывается действительно конечным, а у лямбда-выражений собственный
параметр this отсутствует.)

Следует, однако, иметь в виду, что локальная переменная из объемлющей области видимости не может быть видоизменена в
лямбда-выражении. Ведь это нарушило бы ее действительно конечное состояние, а следовательно, привело бы к недопустимому
ее захвату.

[Chapter15/Package06/VarCapture - Пример захвата локальной переменной из объемлющей области видимости](https://github.com/Vladlena2/BookJava2/blob/master/Chapter15/Package06/VarCapture.java "Посмотреть пример Java")

Следует особо подчеркнуть, что в лямбда-выражении можно использовать и видоизменять переменную экземпляра из
вызывающего его класса. Но нельзя использовать локальную переменную из объемлющей его области видимости, если только эта
переменная не является действительно конечной.
</details>

<details><summary>Ссылки на статические методы</summary>

**Ссылки на методы**

С лямбда-выражениями связано еще одно очень важное средство, называемое
ссылкой на метод. Такая ссылка позволяет обращаться к методу, не вызывая его.
Она связана с лямбда-выражениями потому, что ей также требуется контекст це
левого типа, состоящий из совместимого функционального интерфейса. Имеются
разные виды ссылок на методы. Рассмотрим сначала ссылки на статические методы.

Для создания ссылки на статический метод служит следующая общая форма:
   
      имя_класса :: имя_метода

Обратите внимание на то, что имя класса в этой форме отделяется от имени
метода двоеточием (::). Этот новый разделитель внедрен в версии JDK 8 специально для данной цели. Такой ссылкой на метод можно пользоваться везде, где она
совместима со своим целевым типом.

В следующем примере программы демонстрируется применение ссылки на ста
тический метод:

[Chapter15/Package07/MethodRefDemo - Продемонстрировать ссылку на статический метод](./Chapter15/Package07/MethodRefDemo.java "Посмотреть пример Java")

</details>

<details><summary>Ссылки на методы экземпляра</summary>

Для передачи ссылки на метод экземпляра для конкретного объекта служит следующая общая форма:

```java
 ссылка_на_объект :: имя_метода
```

[Chapter15/Package08/MethodRefDemo2 - Пример применения ссылки на метод экземпляра](https://github.com/Vladlena2/BookJava2/blob/master/Chapter15/Package08/MethodRefDemo2.java "Посмотреть пример Java")

Возможны и такие случаи, когда требуется указать метод экземпляра, который будет использоваться вместе с любым объектом
данного класса, а не только суказанным объектом. В подобных случаях можно создать ссылку на метод экземпляра в следующей
общей форме:

```java
 имя_класса::имя_метода_экземпляра
```

В этой форме *имя_класса* заменяет имя конкретного объекта, несмотря на то, что в ней указывается и метод экземпляра. В
соответствии с этой формой первый параметр метода из функционального интерфейса совпадает с вызывающим объектом, а
второй параметр - с параметром, указанным в методе экземпляра.

Следующий пример программы, в которой определяется метод counter(), подсчитывающий количество объектов в массиве,
удовлетворяющих условию, определяемому в методе func() из функционального интерфейса MyFunc.  
В данном случае подсчитываются экземпляры класса HighTemp.

[Chapter15/Package08/InstanceMethWithObjectRefDemo - Пример использования ссылки на метод экземпляра вместе с разными объектами](https://github.com/Vladlena2/BookJava2/blob/master/Chapter15/Package08/InstanceMethWithObjectRefDemo.java "Посмотреть пример Java")

В данном примере проrраммы в классе HighTemp объявлены два метода экземпляра: sameTemp() и lessThanTemp(). Первый метод
возвращает логическое значение true, если оба объекта типа HighTemp содержат одинаковую температуру. А второй метод
возвращает логическое значение true, если температура в вызывающем объекте меньше, чем в передаваемом. Каждый из этих
методов принимает параметр типа HighTemp и возвращает
соответствующее логическое значение. Следовательно, каждый из них совместим с функциональным интерфейсом MyFunc,
поскольку тип вызывающего объекта может быть приведен к типу первого параметра метода func(), а тип ero аргумента - к
типу второго параметра этого метода.   
Таким образом, когда следующее выражение:

```java
 HighTemp::sameTemp
```

передается методу counter(), создается экземпляр функционального интерфейса MyFunc, где тип первого параметра метода
func() соответствует типу объекта, вызывающего метод экземпляра, т.е. типу HighTemp. А тип второго параметра метода
func() также соответствует типу HighTemp, поскольку это тип параметра метода экземпляра sameTemp(). Это же справедливо и
для метода экземпляра lessThanTemp().
</details>

<details><summary>Ссылки на обобщенные методы</summary>

Ссылками на методы можно также пользоваться для обращения к обобщенным классам и/или методам.

[Chapter15/Package08/GenericMethodRefDemo - Пример применения ссылки на обобщенный метод, объявленный в необобщенном классе](https://github.com/Vladlena2/BookJava2/blob/master/Chapter15/Package08/GenericMethodRefDemo.java "Посмотреть пример Java")

Ссылки на методы могут, в частности, оказаться очень полезными в сочетании с каркасом коллекций *Collectioпs Framework*
Обнаружить в коллекции наибольший элемент можно, в частности, вызвав метод max(), определенный в классе *Collections*.
Пример создания коллекции типа *ArrayList* объектов типа MyClass и поиска в ней наибольшего значения, определяемого в
методе сравнения.

[Chapter15/Package08/ArrayListUseMethRef - Пример использования ссылки на метод, чтобы найти максимальное значение в коллекции ArrayList](https://github.com/Vladlena2/BookJava2/blob/master/Chapter15/Package08/ArrayListUseMethRef.java "Посмотреть пример Java")
</details>

<details><summary>Ссылки на конструкторы</summary>

Ссылки на конструкторы можно создавать таким же образом, как и ссылки на методы.  
Общая форма синтаксиса, которую можно употреблять для создания ссылок на конструкторы.

```java
 имя_класса::new
```

Эта ссылка может быть присвоена любой ссылке на функциональный интерфейс, в котором определяется метод, совместимый с
конструктором.

[Chapter15/Package09/ConstructorRefDemo - Пример применения ссылки ссылки на конструктор](https://github.com/Vladlena2/BookJava2/blob/master/Chapter15/Package09/ConstructorRefDemo.java "Посмотреть пример Java")

Продемонстрируем более практический пример применения ссылок на конструкторы, где употребляется статический метод
myClassFactory(), который является *ФАБРИЧНЫМ* для объектов класса любого типа, реализующего интерфейс MyFunc. С помощью
этого метода можно создать объект любого типа, имеющего конструктор, совместимый с его первым параметром.

[Chapter15/Package09/FactoryConstructorRefDemo - Реализовать простую фабрику классов, используя ссылку на конструктор](https://github.com/Vladlena2/BookJava2/blob/master/Chapter15/Package09/FactoryConstructorRefDemo.java "Посмотреть пример Java")

Для создания ссылки на конструктор *массива* служит следующая форма:

```java
 тип[]::new
```

</details>

<details><summary>Предопределенные функциональные интерфейсы</summary>

Зачастую определять собственный функциональный интерфейс не требуется, поскольку в пакете *java.util.function*
предоставляется целый ряд предопределенных функциональных интерфейсов.

```
UnaryOperator<T>   Выполняет унарную операцию над объектом типа Т и возвращает результат того же типа. Содержит метод apply()
BinaryOperator<T>  Выполняет логическую операцию над двумя объектами типа T и возвращает результат того же типа. Содержит метод apply()
Consumer<T>        Выполняет операцию над объектом типа T. Содержит метод accept()
Supplier<T>        Возвращает объект типа T. Содержит метод get() 
Function<T, R>     Выполняет операцию над объектом типа Т и возвращает в результате объект типа R. Содержит метод apply()
Predicate<T>       Определяет, удовлетворяет ли объект типа T некоторому ограничительному условию. Возвращает логическое значение, обозначающее результат. Содержит метод test() 
```

[Chapter15/Package09/FactorialUseFunctionInterface - Определение ФАКТОРИАЛА используя предопределенный функциональный интерфейс](https://github.com/Vladlena2/BookJava2/blob/master/Chapter15/Package09/FactorialUseFunctionInterface.java "Посмотреть пример Java")

</details>

</blockquote>
</details>

<details ГЛАВА 16><summary>ГЛАВА 16. "Модули"</summary>

<small>

*эта глава (Chapter16) для Idea добавляется в исключения и выполняется из кмандной строки*

</small>


> С выходом JDK 9 в языке Java появилась новая возможность - *модульность*.   
> *Модуль* - это, по существу, группа пакетов и ресурсов, к каждому из которых можно обращаться по имени модуля. В
> объявлении модуля указывается его имя и определяется взаимосвязь данного модуля и составляющих его пакетов с другими
> модулями.
>
>Объявление модуля содержится в файле *module-info.java*, а следовательно, модуль определяется в исходном файле Java.
> Этот файл затем компилируется утилитой *javac* в файл класса и называется *дескриптором* данного модуля. Файл *
> module-info.java* должен содержать исключительно только объявления модулей.
>
>Объявление модуля начинается с ключевого слова *module*. Общая форма объявления модулей.
>```java
> module имяМодуля {
> // определение модуля
> }
>```
>Здесь *имяМодуля* обозначает наименование объявляемого модуля и должно быть достоверным идентификатором Java или
> последовательным рядом таких идентификаторов, разделяемых запятыми. Определение модуля указывается в фигурных скобках.
> И
> хотя оно может быть пустым, когда в объявлении модуля указывается только его имя, в определении модуля, как правило,
> указывается одно или больше предложений, где задаются характеристики данного модуля.
>
>**Создание модуля.**
>
>Определим и используем простейший модуль. В качестве названия модуля может использоваться произвольный идентификатор из
> алфавитно-цифровых символов и знаков подчеркивания. Но рекомендуется, чтобы название модуля соответствовало названию,
> которого начинаются пакеты этого модуля.
> Создадим в рабочей директории с исходными кодами новый каталог ./demo. Он послужит каталогом верхнего уровня для всего
> приложения в целом.
> Создадим в нем следующую структуру каталогов, которая будет выглядеть следующим образом:
>```
>      \demo
>        |
>      appsrc
>      /    \
>     /      \
>apprun     appfunc
>    |        |
>apprun     appfunc
>    |        |
>appdemo    simplefunc
>```
>
>В каталоге **.\demo\appsrc\appfunc\appfunc\simplefunc**  
> создадим файл **SimpleMathFuncs.java**  
> В этом классе определяются три статических метода, реализующих простые математические функции.
>
>В каталоге **.\demo\appsrc\apprun\apprun\appdemo**  
> создадим файл **AppRunDemo.java**  
> В этом классе вызываются методы из класса **SimpleMathFuncs**.
>
>Далее в каталоге **.\demo\appsrc\appfunc**  
> определим новый файл **module-info.java** со следующим кодом:
>```java
>// Определение модуля математических функций
>module appfunc {
>    // экспортировать пакет appfunc.simplefunc
>    exports Chapter16.demo.appsrc.appfunc.appfunc.simplefunc;
>}
>```
>В каталоге **.\demo\appsrc\apprun**   
> также определим новый файл **module-info.java** со следующим кодом:
>```java
>// Определение главного модуля приложения
>module apprun {
>   // определение модуля, требуется модуль appfunc
>   requires appfunc;
>}
>```
>
>**Компиляция и выполнение первого примера модульного приложения**
>
>Для компиляции модуля в среде Windows, выполним следующие команды для (SimpleMathFuncs.java и module-info.java):
>```
>javac -d appmodules\appfunc appsrc\appfunc\appfunc\simplefunc\SimpleMathFuncs.java
>javac -d appmodules\appfunc appsrc\appfunc\module-info.java
>```
>Можно объединить эти две команды в одну:
>``` 
>javac --module-path appmodules -d appmodules\appfunc appsrc\appfunc\module-info.java appsrc\appfunc\appfunc\simplefunc\SimpleMathFuncs.java
>```
>
>Далее выполним компиляцию для (AppRunDemo.java и module-info.java):
>``` 
>javac --module-path appmodules -d appmodules\apprun appsrc\apprun\module-info.java appsrc\apprun\apprun\appdemo\AppRunDemo.java
>```
>
>Запуск модульного приложение в среде Windows по следующей команде:
>```
>chcp 65001
>java --module-path appmodules -m apprun/Chapter16.demo.appsrc.apprun.apprun.appdemo.AppRunDemo
>```

#### Типы модулей

- Project Jigsaw классифицирует модули следующим образом:
- System Modules — Java SE и JDK модули. Полный список можно посмотреть, используя команду java --list-modules.
- Application Modules — модули нашего приложения, которые мы написали, а также те зависимости (от сторонних библиотек), которые использует наше приложение.
- Automatic Modules — это модули с открытым доступом, создаваемые Java автоматически из JAR-файлов. Допустим, мы хотим запустить наше приложение в модульном режиме, но оно использует какую-то библиотеку. В этом случае мы помещаем JAR-файл на --module-path и Java автоматически создает модуль с именем, унаследованным от имени JAR-файла.
- Unnamed Module — безымянный модуль, автоматически создаваемый из всех JAR-файлов, которые загружены на --class-path. Это универсальный модуль для обеспечения обратной совместимости с ранее написанным Java кодом.

#### Ключевые слова:

- requires указывает модули, от которых зависит текущий модуль;
- requires transitive — транзитивная зависимость — означает следующее: если модуль m1 транзитивно зависит от модуля m2, и мы имеем какой-то третий модуль mX, который зависит от m1 — модуль mX будет иметь доступ также и к m2;
- requires static позволяет указать compile-time зависимости;
- exports указывает пакеты, которые экспортирует текущий модуль (не включая “подпакеты”);
- exports...to… позволяет ограничить доступ: export com.my.package.name to com.specific.package; то есть можно открыть доступ к пакету нашего модуля только для какого-то другого(их) пакета(ов) другого модуля;
- uses указывает, какие сервисы использует модуль:
>``` 
>uses java.sql.Driver;
>```
В данном случае, мы указываем интерфейс используемого сервиса
- provides указывает, какие сервисы предоставляет модуль:
>``` 
>provides javax.tools.Tool with
    jdk.javadoc.internal.api.JavadocTool;
>``` 
Сначала указываем интерфейс — javax.tools.Tool, после with — реализацию.

#### Управление доступом к классам:
   - Модификаторы доступа (public, protected, private) остаются в силе внутри модуля.
   - Внутри модуля классы могут быть доступны только друг другу, если они не являются открытыми.

#### Разрешение конфликтов:
   - При использовании нескольких модулей могут возникнуть конфликты имен пакетов или классов.
   - Ключевое слово open используется для открытия пакета, чтобы другие модули могли получить доступ к рефлексии.

#### Сервисные провайдеры:
   - Модульная система поддерживает понятие сервисных провайдеров, позволяя легко регистрировать и обнаруживать сервисы.

#### Пример использования:
   - Давайте представим, что у нас есть проект, состоящий из нескольких модулей: core, ui и database.
   - Модуль core содержит основную функциональность, ui - пользовательский интерфейс, а database - доступ к базе данных.
   - Модули зависят друг от друга, но могут быть легко развернуты и масштабированы.

</blockquote>
</details>

<details ГЛАВА 17><summary>ГЛАВА 17. "Выражения switch, записи и прочие недавно добавленные средства"</summary>
<blockquote>

<details><summary>Выражения switch</summary>

В Java оператор `switch` используется для выбора одного из множества возможных путей выполнения кода, основываясь на значении выражения. Расширения оператора `switch` появились в Java 12 и позволяют улучшить читаемость и гибкость кода при работе с оператором `switch`. Давайте рассмотрим подробнее, что это за расширения и как они работают.

### До Java 12:

До появления расширений оператора `switch`, оператор `switch` в Java имел следующий синтаксис:

```java
switch (выражение) {
    case значение1:
        // код, выполняемый при соответствии выражения значению1
        break;
    case значение2:
        // код, выполняемый при соответствии выражения значению2
        break;
    // Другие случаи
    default:
        // код, выполняемый по умолчанию, если ни одно из значений не соответствует
}
```

### Расширения оператора `switch` в Java 12:

Расширения оператора `switch` в Java 12 добавили следующие возможности:

1. **Выражения `case` могут быть константными выражениями**:
   Теперь в `case` можно использовать не только константные значения, но и константные выражения. Это позволяет более гибко и эффективно использовать `switch`.

   Пример:

   ```java
   int dayOfWeek = 5;
   switch (dayOfWeek) {
       case 1, 2, 3, 4, 5 -> System.out.println("Рабочий день");
       case 6, 7 -> System.out.println("Выходной день");
       default -> System.out.println("Некорректный день недели");
   }
   ```

2. Добавление стрелки (`->`), которая используется для указания действия, которое должно быть выполнено при соответствии конкретному случаю в `switch`.

Вот как это выглядит:

```java
int dayOfWeek = 5;
switch (dayOfWeek) {
    case 1, 2, 3, 4, 5 -> System.out.println("Рабочий день");
    case 6, 7 -> System.out.println("Выходной день");
    default -> System.out.println("Некорректный день недели");
}
```

Здесь `->` используется для указания действия, которое должно быть выполнено, если значение `dayOfWeek` соответствует одному из значений в `case`.

Это важное дополнение, так как делает код более компактным и улучшает его читаемость, особенно в сравнении с традиционным способом записи `switch`.

Еще один пример:
```java
class Vowels {
    public static void main(String[] args) {
        // Если буква У должна считаться гласной, тогда эту переменную
        // необходимо установить в true.
        boolean isVowel = true;
        char ch = 'У';
        boolean isVowel = switch (ch) {
            case 'а', 'е', 'i', 'о', 'u', 'А', 'Е', 'I', 'О', 'U' -> true;
            case 'у', 'У' -> isVowel ? true : false;
            default -> false;
        };
        if (isVowel)
            System.out.println(ch + " является гласной буквой.");
    }
}
```

3. **Введение ключевого слова `yield`**:
   `yield` используется для возврата значения из блока `case`. Это позволяет использовать `switch` в выражениях, где требуется возвращаемое значение.

   Пример:

   ```java
   String result = switch (dayOfWeek) {
       case 1, 2, 3, 4, 5 -> "Рабочий день";
       case 6, 7 -> "Выходной день";
       default -> {
           yield "Некорректный день недели";
       }
   };
   System.out.println(result);
   ```

4. **Тело `switch` может быть блоком**:
   Теперь тело `switch` может быть блоком кода, что позволяет более гибко структурировать код внутри `switch`.

   Пример:

   ```java
   switch (dayOfWeek) {
       case 1, 2, 3, 4, 5 -> {
           System.out.println("Рабочий день");
           System.out.println("Пора на работу");
       }
       case 6, 7 -> {
           System.out.println("Выходной день");
           System.out.println("Можно отдохнуть");
       }
       default -> System.out.println("Некорректный день недели");
   }
   ```

Расширения оператора `switch` в Java 12 упрощают и улучшают читаемость кода, делая его более гибким и эффективным. Они дают разработчикам больше возможностей при использовании `switch`, что способствует написанию более краткого и чистого кода.

</details>

<details><summary>Текстовые блоки</summary>

<details><summary>Основы текстовых блоков</summary>
  
В Java текстовые блоки представляются в виде строковых литералов, которые могут располагаться на нескольких строках и поддерживают вставку переменных и выражений. С текстовыми блоками, введенными в Java 13, вы можете упростить создание многострочных строковых значений без необходимости экранирования специальных символов или использования конкатенации строк.

Вот пример использования текстового блока в Java:

```java
public class Main {
    public static void main(String[] args) {
        String textBlock = """
            Это пример текстового блока в Java.
            Он может занимать несколько строк,
            и вы можете использовать специальные символы, такие как \n,
            без необходимости их экранирования.
            
            Текстовые блоки также поддерживают вставку переменных, например,
            значение переменной x = %d может быть вставлено непосредственно сюда.
            """.formatted(42);
        
        System.out.println(textBlock);
    }
}
```

В этом примере мы использовали текстовый блок, начинающийся с тройных кавычек `"""` и заканчивающийся таким же образом. Между ними мы написали многострочный текст, который будет присвоен переменной `textBlock`. В этом тексте мы также использовали специальные символы, такие как перевод строки `\n`, без необходимости их экранирования. Мы также использовали метод `formatted()`, чтобы вставить значение переменной `x` в текстовый блок.

Текстовые блоки в Java предоставляют удобный способ создания и манипулирования многострочными строками, что делает код более читаемым и поддерживаемым.

**Текстовые блоки в Java: Подробный конспект**

---

**1. Как создать текстовый блок?**

Текстовый блок создается путем размещения строки внутри тройных символов двойных кавычек `"""`. Текстовый блок начинается сразу за символом новой строки после открывающего разделителя `"""` и заканчивается на первом символе закрывающего разделителя `"""`.

Пример:
```
String textBlock = """
    Это текстовый блок.
    Он может занимать несколько строк.
    """;
```

---

**2. Особенности текстовых блоков:**

- Текстовые блоки автоматически сохраняют символы новой строки в тексте.
- Нет необходимости в экранировании специальных символов, таких как `\n`.
- Текстовый блок начинается на новой строке и заканчивается на новой строке, сохраняя символ новой строки после второй строки.

---

**3. Присвоение текстовых блоков переменным типа String:**

Текстовые блоки, хотя и используют разделитель `"""`, относятся к типу `String`. Таким образом, можно присвоить текстовый блок переменной типа `String`.

Пример:
```
String str = """
    Это текстовый блок.
    """;
```

---

**4. Вывод текстовых блоков:**

При выводе текстовых блоков с помощью `System.out.println()` символы новой строки сохраняются и выводятся соответственно.

Пример:
```
System.out.println(str);
```
Вывод:
```
Это текстовый блок.
```

---

**5. Завершающий символ новой строки:**

Если необходимо исключить завершающий символ новой строки, закрывающий разделитель следует разместить в конце последней строки текстового блока.

Пример:
```
String str = """
    Это текстовый блок без завершающего символа новой строки.""";
```

---

</details>

<details><summary>Ведущие пробельные символы</summary>

**Ведущие пробельные символы**

В предыдущем примере текст в блоке был выровнен по левому краю, однако это не обязательное требование. В текстовом блоке могут присутствовать ведущие пробельные символы. Существует две основные причины, по которым они могут быть полезными. Во-первых, они позволяют лучше выровнять текст относительно уровня отступа кода вокруг него. Во-вторых, они поддерживают один или несколько уровней отступов внутри самого текстового блока.

Обычно ведущие пробельные символы в текстовом блоке автоматически удаляются. Однако количество ведущих пробельных символов, которые подлежат удалению из каждой строки, определяется числом ведущих пробельных символов в строке с наименьшим отступом. Например, если все строки выровнены по левому краю, то никакие пробельные символы не удаляются. Если все строки имеют одинаковый отступ в два пробела, то из каждой строки удаляются два пробела. Однако, если разные строки имеют разный отступ (например, 2, 4 и 6 пробелов), то из каждой строки удаляется только соответствующее количество пробельных символов.

Этот механизм позволяет удалить ненужные ведущие пробельные символы, сохраняя при этом отступы текста внутри блока.

Пример ниже иллюстрирует использование ведущих пробельных символов в текстовом блоке:

```java
class TextBlockDemo {
    public static void main(String[] args) {
        String str =
            Текстовые блоки поддерживают строки, которые 
              распространяются на две и большее количество 
                строчек и предохраняют отступы. Они позволяют 
              менее утомительно вводить длинные или сложные 
            строки в программе.
        ;

        System.out.println(str);
    }
}
```

Вывод программы:

```
Текстовые блоки поддерживают строки, которые 
  распространяются на две и большее количество 
    строчек и предохраняют отступы. Они позволяют 
  менее утомительно вводить длинные или сложные 
строки в программе.
```

В данном примере ведущие пробельные символы были удалены до уровня крайних левых строк, сохраняя при этом отступы текста внутри блока.

Еще один важный момент: закрывающий разделитель """ участвует в определении объема удаляемых пробельных символов, так как он также может устанавливать уровень отступа. Если закрывающий разделитель выровнен по левому краю, пробельные символы не удаляются. В противном случае пробельные символы удаляются до тех пор, пока не встретится первый символ текста или закрывающий разделитель. Рассмотрим следующую последовательность:

```java
String str = """
    А
       B
    C 
""""; // определяет начало отступа 
    
String str2 = """
    А
       B
    C 
      """";     // никакого влияния не оказывает 
    
String str3 ="""
    А
       B
    C 
   """"; 
    // приводит к удалению пробельных символов вплоть до """"

System.out.print(str); 
System.out.print(str2); 
System.out.print(str3);
```

Вывод:

```
    А
       B
    C 
А
   B
C
  А
     B
  C
```

Обратите внимание на размещение закрывающего разделителя для строки `str2`. Из-за того, что количество предшествующих пробелов в строках, содержащих "А" и "С", меньше числа пробелов перед """, закрывающий разделитель участвует в определении уровня отступа.

Другим важным преимуществом текстовых блоков является возможность указания двойных кавычек без необходимости применения управляющей последовательности \". Двойные кавычки в текстовом блоке трактуются подобно любому другому символу. Вот пример программы:

```java
// Использование двойных кавычек в текстовом блоке.
class TextBlockDemo2 {
    public static void main(String[] args) {
        String str = """
                      Внутри текстового блока можно указывать двойные кавычки без необходимости
                      в использовании управляющих последовательностей. Например:
                      Он сказал: "На крыше кот".
                      Она спросила: "Как он туда попал?"
                      """;
        System.out.println(str);
    }
}
```

Вывод программы:

```
Внутри текстового блока можно указывать двойные кавычки без необходимости
в использовании управляющих последовательностей. Например:
Он сказал: "На крыше кот".
Она спросила: "Как он туда попал?"
```

Как видите, использовать управляющую последовательность \" не пришлось. Кроме того, поскольку двойные кавычки рассматриваются как "нормальные" символы, нет необходимости применять их сбалансированным образом внутри текстового блока. Например, вот вполне приемлемый текстовый блок:

```java
"абв"
```

Просто помните, что три двойные кавычки как единое целое определяют разделитель текстового блока.
</details>

</details>

<details><summary>Записи</summary>

До появления записей в Java, для хранения группы значений приходилось создавать классы, что часто требовало написания большого количества кода для конструкторов, методов доступа и, возможно, переопределения методов, унаследованных от класса Object. Однако с появлением записей в JDK 16 упомянутые задачи обрабатываются автоматически, что значительно упрощает процесс.

Вот пример использования записи для хранения данных о сотруднике:

```java
record Employee(String name, int idNum) {}
```

Здесь запись названа "Employee" и состоит из двух компонентов: строки "name" и целого числа "idNum". Тело записи пустое, потому что компилятор автоматически предоставляет необходимые элементы, такие как конструктор, методы доступа и переопределенные методы toString(), equals() и hashCode(). 

Использование записей облегчает работу с группами данных и позволяет четко указывать их назначение. Кроме того, ключевое слово "record" контекстно-чувствительное, что позволяет добавить его в язык без нарушения существующего кода.

При объявлении записи, как в случае с Employee, компилятор автоматически создает несколько элементов:

1. Для каждого компонента записи (в данном случае "name" и "idNum") создаются закрытые финальные поля с соответствующими типами данных (String и int).
2. Предоставляются открытые методы доступа, которые допускают только чтение (методы получения). Названия и типы этих методов соответствуют компонентам записи, например, "name()" и "idNum()".
3. Создается канонический конструктор записи, который имеет список параметров, содержащий те же элементы в том же порядке, что и список компонентов в объявлении записи. Значения, передаваемые этому конструктору, автоматически присваиваются соответствующим полям в записи.

Таким образом, при создании экземпляра записи с помощью оператора `new`, например:

```java
Employee emp = new Employee("Doe, John", 1047);
```

Поля `name` и `idNum` в объекте `emp` будут содержать значения "Doe, John" и 1047 соответственно. Также можно использовать методы получения для доступа к этим значениям, например:

```java
System.out.println("Идентификатором сотрудника " + emp.name() + " является " + emp.idNum());
```

Что выведет:

```
Идентификатором сотрудника Doe, John является 1047
```

Одним из ключевых аспектов записей является то, что их данные хранятся в закрытых финальных полях, и доступ к ним осуществляется только через методы получения. Это делает содержимое записи неизменяемым (immutable). То есть, после создания экземпляра записи его данные нельзя изменить. Однако, если запись содержит ссылку на объект, то в этот объект можно вносить изменения, но нельзя изменить ссылку на объект, на который ссылается запись. Таким образом, в терминологии Java записи являются поверхностно неизменяемыми (shallowly immutable).

</details>

<details><summary>Создание конструкторов записи</summary>

Для определения собственной реализации канонического конструктора записи просто опишите конструктор, указав имя записи и список его параметров. Важно, чтобы типы и имена параметров совпадали с указанными в объявлении записи, так как они связаны с автоматически создаваемыми полями и методами доступа. После завершения конструктора каждый компонент должен быть полностью инициализирован.

Однако есть несколько ограничений:
- Конструктор должен быть не менее доступным, чем модификатор доступа, указанный в объявлении записи.
- Он не может быть обобщенным и не может содержать оператор throws.
- Конструктор не может вызывать другие конструкторы, определенные для записи.

Пример записи Employee с явно определенным каноническим конструктором, который удаляет ведущие и завершающие пробельные символы из имени, показан ниже:

```java
record Employee(String name, int idNum) {
    // Явное определение канонического конструктора для удаления пробелов из имени.
    public Employee(String name, int idNum) {
        // Удаление ведущих и завершающих пробельных символов из имени.
        this.name = name.trim();
        this.idNum = idNum;
    }
}
```

Этот конструктор принимает имя и идентификационный номер сотрудника. Затем он удаляет ведущие и завершающие пробелы из имени, используя метод `trim()`, чтобы гарантировать хранение имен в согласованной манере.

Конечно, вот переписанная программа:

```java
// Объявление записи для сотрудника
record Employee(String name, int idNum) {
    // Статическое поле для ожидающего идентификационного номера
    static int pendingID = -1;

    // Компактный канонический конструктор для удаления ведущих и завершающих пробелов из имени
    public Employee {
        name = name.trim();
    }

    // Неканонический конструктор, инициализирующий имя и устанавливающий ожидающий идентификационный номер
    public Employee(String name) {
        // Вызов канонического конструктора с ожидающим идентификационным номером
        this(name, pendingID);
    }
}

public class RecordDemo3 {
    public static void main(String[] args) {
        // Создание массива записей сотрудников
        Employee[] empList = new Employee[4];

        // Инициализация записей сотрудников
        empList[0] = new Employee("Doe, John", 1047);
        empList[1] = new Employee("Jones, Robert", 1048);
        empList[2] = new Employee("Smith, Rachel", 1049);
        // Создание записи с именем, но без идентификационного номера
        empList[3] = new Employee("Martin, Dave");

        // Отображение информации о сотрудниках
        for (Employee emp : empList) {
            System.out.print("Идентификатором сотрудника " + emp.name() + " является ");
            if (emp.idNum() == Employee.pendingID) {
                System.out.println("ожидающий");
            } else {
                System.out.println(emp.idNum());
            }
        }
    }
}
```

Эта программа создает записи для нескольких сотрудников с использованием различных конструкторов. После этого она отображает информацию о каждом сотруднике, включая его имя и идентификационный номер или статус "ожидающий", если идентификационный номер недоступен.

Данный код представляет компактный канонический конструктор для записи `Employee`, который выполняет удаление ведущих и завершающих пробелов в компоненте `name` и проводит базовую проверку формата имени.

```java
// Использование компактного канонического конструктора для удаления 
// любых ведущих и завершающих пробелов в компоненте name. Кроме того, 
// реализуется базовая проверка того, что строка, переданная в параметре 
// name, представлена в требуемом формате "фамилия, имя". 
public Employee {
    // Удалить любые ведущие и завершающие пробелы. 
    name = name.trim(); 
    // Выполнить минимальную проверку того, что name 
    // находится в формате "фамилия, имя". 
    // Сначала удостовериться, что name содержит только одну запятую. 
    int i = name.indexOf(','); // искать разделяющую запятую 
    int j = name.lastIndexOf(','); 
    if(i != j) 
        throw new IllegalArgumentException("Обнаружено несколько запятых."); 
    // Затем удостовериться, что до и после запятой имеется 
    // хотя бы по одному символу. 
    if (i < 1 || name.length() == i + 1) 
        throw new IllegalArgumentException("Требуемый формат: фамилия, имя"); 
}
```

Этот конструктор удаляет ведущие и завершающие пробелы в имени сотрудника и проверяет, что имя имеет формат "фамилия, имя". Если формат не соответствует этим условиям, выбрасывается исключение `IllegalArgumentException`.

</details>

</blockquote>
</details>
