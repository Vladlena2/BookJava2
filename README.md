## Книга "Java полное руководство - Герберт Шилдт, 12-е издание, 2022г."

<small>

#### Оглавление

<details ГЛАВА 13><summary>ГЛАВА 13. "Ввод-вывод, оператор try с ресурсами и др."</summary>
<blockquote>

<details><summary>Ввод-вывод</summary>

Поддержка ввода-вывода обеспечивается основными библиотеками Java API, а не системными библиотеками языка.

<details><summary>Потоки данных</summary>

Ввод и вывод данных в Java-программах осуществляется через потоки данных. Поток данных - это абстракция, которая может производить или потреблять информацию. Поток связывается с физическим устройством посредством системы ввода-вывода Java. Классы и методы ввода-вывода можно применять к различным типам устройств, таким как дисковые файлы, клавиатура или сетевые соединения. Это позволяет абстрагироваться от множества различных видов ввода. Вывод данных может осуществляться на консоль, в дисковый файл или по сетевому соединению. Потоки данных в Java реализованы в иерархиях классов, определенных в пакете java.io.

Java также предоставляет ввод-вывод на основе буферов и каналов, которые определены в пакете java.nio и его подпакетах.

</details>

<details><summary>Потоки байтовых и символьных данных</summary>

В Java существуют два типа потоков ввода/вывода: байтовые и символьные. Байтовые потоки удобны для обработки ввода и вывода байтовых данных, например при чтении или записи двоичных данных. Символьные потоки используют Unicode и позволяют обрабатывать ввод и вывод символов, обеспечивая поддержку интернационализации. В некоторых случаях символьные потоки более эффективны, чем байтовые.

На самом низком уровне операции ввода-вывода по-прежнему выполняются с байтами. Символьные потоки предоставляют удобный и эффективный способ работы со символами в кодировке Unicode.
  
</details>

<details><summary>Классы потоков байтовых данных</summary>

**Классы потоков ввода-вывода байтов из пакета java.io**

Потоки ввода-вывода байтов определены в двух иерархиях классов. На вершине этих иерархий находятся _абстрактные классы InputStream и OutputStream_. У каждого из этих абстрактных классов имеется несколько конкретных подклассов, в которых учитываются отличия разных устройств, в том числе файлов на диске, сетевых соединений и даже буферов памяти.

```html
BufferedInputStream    Буферизованный поток ввода  
BufferedOutputStream   Буферизованный поток вывода  
ByteArrayinputStream   Поток ввода, читающий байты из массива  
ByteArrayOutputStream  Поток вывода, записывающий байты в массив  
DataInputStream        Поток ввода, содержащий методы для чтения данных стандартных типов, определенных в Java  
DataOutputStream       Поток вывода, содержащий методы для записи данных стандартных типов, определенных в Java  
FileInputStream        Поток ввода, читающий данные из файла  
FileOutputStream       Поток вывода, записывающий данные в файл  
FilterInputStream      Реализует абстрактный класс InputStream  
FilterOutputStream     Реализует абстрактный класс OutputStream  
InputStream            Абстрактный класс, описывающий поток ввода  
ObjectInputStream      Поток ввода объектов  
ObjectOutputstream     Поток вывода объектов  
OutputStream           Абстрактный класс, описывающий поток вывода  
PipedInputStream       Канал ввода  
PipedOutputstream      Канал вывода  
PrintStream            Поток вывода, содержащий методы print() и println()  
PushbackInputStream    Поток ввода, поддерживающий возврат одного байта обратно в поток ввода  
SequenceInputStream    Поток ввода, состоящий из нескольких потоков ввода, данные из которых читаются по очереди  
```

В абстрактных классах InputStream и OutputStream определяется ряд ключевых методов, реализуемых в других классах потоков ввода-вывода. Наиболее важными среди них являются методы read() и writе(), читающие и записывающие байты данных соответственно. Оба эти метода объявлены как абстрактные в классах InputStream и OutputStream, а в производных классах они переопределяются.

**Классы потоков ввода-вывода символов**

Потоки ввода-вывода символов также определены в двух иерархиях классов. На вершине этих иерархий находятся два * абстрактных* класса - Reader и Writer. Эти абстрактные классы управляют потоками символов в Юникоде. Для каждого из них в Java предусмотрен ряд конкретных подклассов.

```html
BufferedReader         Буферизированный поток ввода символов  
BufferedWriter         Буферизированный поток вывода символов  
CharArrayReader        Поток ввода, читающий символы из массива  
CharArrayWriter        Поток вывода, записывающий символы в массив  
FileReader             Поток ввода, читающий символы из файла  
FileWriter             Поток вывода, записывающий символы в файл  
FilterReader           Фильтрованный поток чтения  
FilterWriter           Фильтрованный поток запис  
InputStreamReader      Поток ввода, преобразующий байты в символы  
LineNumЬerReader       Поток ввода, подсчитывающий строки  
OutputStreamWriter     Поток вывода, преобразующий символы в байты  
PipedReader            Канал ввода  
PipedWriter            Канал вывода  
PrintWriter            Поток вывода, содержащий методы print() и println()  
PushbackReader         Поток ввода, позволяющий возвращать символы обратно в поток ввода  
Reader                 Абстрактный класс, описывающий поток ввода символов  
StringReader           Поток ввода, читающий символы из строки  
StringWriter           Поток вывода, записывающий символы в строку  
Writer                 Абстрактный класс, описывающий поток вывода символов   
```

В абстрактных классах Reader и Writer определяется ряд ключевых методов, реализуемых в других классах потоков ввода-вывода. Наиболее важными среди них являются методы read() и write(), читающие и записывающие байты данных соответственно. Оба эти метода объявлены как абстрактные в классах Reader и Writer, а в производных классах они переопределяются.

</details>

<details><summary>Предопределенные потоки данных</summary>

Класс System содержит несколько методов для получения информации о системе и текущего времени, а также три предопределенных потоковых переменных: in, out и err, которые могут быть использованы в любой части программы без привязки к конкретному экземпляру класса System.

Переменная System.out ссылается на поток стандартного вывода, по умолчанию вывод осуществляется на консоль. System.in ссылается на поток стандартного ввода, по умолчанию принимаемые данные поступают с клавиатуры. System.err ссылается на поток вывода ошибок, также по умолчанию вывод ошибок осуществляется на консоль. Эти потоки могут быть перенаправлены на другие устройства ввода-вывода, поддерживающие совместимые форматы данных.

System.in, System.out и System.err являются потоками байтовых данных типа InputStream, PrintStream и ErrorStream соответственно. Однако они обычно используются для чтения и записи символов в консоль. Вы можете использовать их как основу для более сложных операций ввода-вывода или обернуть их в классы символьных потоков для дополнительной гибкости и контроля.

</details>

<details><summary>Чтение консольного ввода</summary>

История Java и консольный ввод:
   - На заре развития Java единственным способом выполнения консольного ввода было использование потока байтовых данных.
   - В настоящее время символьный поток предпочтительнее из-за удобства интернационализации и сопровождения программы.

Java 17 и изменения:
   - В JDK 17 изменился способ получения объекта InputStreamReader, связанного с System.in.
   - Рекомендуется явно указывать набор символов, ассоциированный с консолью, при создании InputStreamReader. Набор символов определяет способ сопоставления байтов с символами. Обычно, когда набор символов не задан, применяется стандартная кодировка 
JVM.

Использование InputStreamReader и BufferedReader:
   - Для чтения консольного ввода через BufferedReader, рекомендуется использовать конструктор InputStreamReader с явным указанием набора символов, ассоциированного с консолью.
   - Можно использовать метод System.console() для получения объекта Console и его метод charset() для получения набора символов консоли.

Создание BufferedReader с использованием InputStreamReader без явного указания набора символов (до JDK 17):

```html
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class ConsoleInputExample {
    public static void main(String[] args) {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        try {
            System.out.print("Введите ваше имя: ");
            String name = br.readLine();
            System.out.println("Привет, " + name + "!");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

Создание BufferedReader с использованием InputStreamReader с явным указанием набора символов (начиная с JDK 17):
 
```html
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.Charset;

public class ConsoleInputExample {
    public static void main(String[] args) {
        InputStreamReader isr = new InputStreamReader(System.in, Charset.defaultCharset());
        BufferedReader br = new BufferedReader(isr);

        try {
            System.out.print("Введите ваше имя: ");
            String name = br.readLine();
            System.out.println("Привет, " + name + "!");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

Современный подход к чтению консольного ввода в Java включает явное указание набора символов консоли при создании InputStreamReader, что обеспечивает более надежное и удобное взаимодействие с консолью в различных приложениях.

</details>

<details><summary>Чтение символов</summary>

Чтобы получить поток ввода символов, присоединив его к консоли, следует заключить стандартный поток ввода System.in в оболочку объекта класса BufferedReader, поддерживающего буферизованный поток ввода. Ниже приведен чаще всего используемый конструктор этого класса.

```html
BufferedReader(Reader поток_чтения_вводимых_данных)  
```

десь параметр поток_чтения_вводимых_данных обозначает поток, который связывается с создаваемым экземпляром класса BufferedReader. Класс Reader является абстрактным. Одним из производных от него конкретных подклассов является класс InputStreamReader, преобразующий байты в символы. Для получения объекта типа InputStreamReader, связанного со стандартным потоком ввода System.in, служит следующий конструктор:

```html
InputStreamReader(InputStream поток_ввода)   
```

Переменная System.in ссылается на объект класса InputStream и поэтому должна быть указана в качестве параметра поток_ввода. В конечном итоге получается приведенная ниже строка кода, где создается объект типа BufferedReader, связанный с клавиатурой. После выполнения этой строки кода переменная экземпляра br будет содержать поток ввода символов, связанный с консолью через стандартный поток ввода System.in.

```html
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
```

Для чтения символа из потока ввода типа BufferedReader служит метод read(). Ниже приведена общая форма метода read().

```html
int read() throws IOException  
```

Всякий раз, когда метод read() вызывается, он читает символ из потока ввода и возвращает его в виде целочисленного значения. По достижении конца потока возвращается значение -1. Как видите, метод read() может сгенерировать исключение типа IOException.

[Chapter13/Package01/BRRead - Использовать класс BufferedReader для чтения символов с консоли](https://github.com/Vladlena2/BookJava/blob/main/Chapter13/Package01/BRRead.java "Посмотреть пример Java")

Для чтения символьных строк с клавиатуры служит версия метода readLine(), который является членом класса BufferedReader. Его общая форма приведена ниже. Как видите, этот метод возвращает объект типа String.

```html
String readLine() throws IOException    
```

[Chapter13/Package01/BRReadLines - Чтение символьных строк с консоли средствами класса BufferedReader](https://github.com/Vladlena2/BookJava/blob/main/Chapter13/Package01/BRReadLines.java "Посмотреть пример Java")

В следующем далее примере программы демонстрируется простейший текстовый редактор. С этой целью сначала создается массив объектов типа String, а затем читаются текстовые строки, каждая из которых сохраняется в элементе массива. Чтение производится до 100 строк или до тех пор, пока не будет введено слово "стоп". Для чтения данных с консоли применяется класс BufferedReader.

[Chapter13/Package01/TinyEdit - Простейший текстовый редактор](https://github.com/Vladlena2/BookJava/blob/main/Chapter13/Package01/TinyEdit.java "Посмотреть пример Java")

</details>

<details><summary>Запись данных, выводимых на консоль</summary>

Вывод данных на консоль проще всего организовать с помощью упоминавшихся ранее методов print() и println(). Эти методы определены в классе PrintStream (он является типом объекта, на который ссылается переменная System.out).

Класс PrintStream описывает поток вывода и является производным от класса OutputStream, поэтому в нем реализуется также низкоуровневый метод write(). Следовательно, метод write() можно применять для записи данных, выводимых на консоль. Ниже приведена простейшая форма метода writе(), определенного в классе PrintStream.

```html
void write(int байтовое_значение)     
```

Этот метод записывает байт, передаваемый в качестве параметра байтовое_значение. Несмотря на то что параметр * байтовое_значение* объявлен как целочисленный, записываются только 8 его младших бит. Ниже приведен короткий пример программы, где метод write() применяется для вывода на экран буквы "А" с последующим переводом строки.

```html
// Продемонстрировать применение метода System.out.write()
class WriteDemo {
   public static void main(String[] args){
       int b;
       b = 'A';
       System.out.write(b);
       System.out.print("\n");
   }
}   
```

**Класс PrintWriter**

Применение класса PrintWriter для консольного вывода упрощает интернационализацию прикладных программ. В классе PrintWriter определяется несколько конструкторов. Ниже приведен один из тех конструкторов:

```html
PrintWriter(OutputStream поток_вывода, boolean очистка)   
```

Здесь параметр поток_вывода обозначает объект типа OutputStream, а параметр очистка - очистку потока вывода всякий раз, когда вызывается (среди прочих) метод println(). Если параметр очистка принимает логическое значение true, то очистка потока вывода происходит автоматически, а иначе - вручную.

В классе PrintWriter поддерживаются методы print() и println(). Следовательно, их можно использовать таким же образом, как и в стандартном по токе вывода System.out. Если аргумент этих методов не относится к простому типу, то для объекта типа PrintWriter сначала вызывается метод toString(), а затем выводится результат.

Чтобы вывести данные на консоль, используя класс PrintWriter, следует указать стандартный поток System.out для вывода и его автоматическую очистку. Например, в следующей строке кода создается объект типа PrintWriter, который связывается с консольным выводом:

```html
PrintWriter pw = new PrintWriter(System.out, true);
```

[Chapter13/Package01/PrintWriterDemo - Продемонстрировать применение класса PrintWriter](https://github.com/Vladlena2/BookJava/blob/main/Chapter13/Package01/PrintWriterDemo.java "Посмотреть пример Java")
       
</details>

<details><summary>Чтение файлов и запись в файлы</summary>

Для ввода-вывода данных в файлы чаще всего применяются классы FileInputStream и FileOutputStream, которые создают потоки ввода-вывода байтов, связанные с файлами. Чтобы открыть файл для ввода-вывода данных, достаточно создать объект одного из этих классов, указав имя файла в качестве аргумента конструктора. У обоих классов имеются и дополнительные конструкторы, но в представленных далее примерах будут употребляться только следующие конструкторы:

```html
FileInputStream(String имя_файла)
   throws FileNotFoundException
FileOutputStream(String имя_файла)
   throws FileNotFoundException
```

Здесь параметр имя_файла обозначает имя того файла, который требуется открыть. Если при создании потока ввода файл не существует, то генерируется исключение типа FileNotFoundException. А если при создании потока вывода файл нельзя открыть или создать, то и в этом случае генерируется исключение типа FileNotFoundException. Класс исключения FileNotFoundException является производным от класса IOException. Когда файл открыт для вывода, любой файл, существовавший ранее под тем же самым именем, уничтожается.

Завершив работу с файлом, его нужно закрыть. Для этой цели служит метод close(), реализованный в классах FileinputStream и F ileOutputStream:

```html
void close() throws IOException
```

Закрытие файла высвобождает выделенные для него системные ресурсы, позволяя использовать их для других файлов. Неудачный исход закрытия файла может привести к **"утечкам памяти"**, поскольку неиспользуемые ресурсы оперативной памяти останутся выделенными.

**На заметку!**

Начиная с версии JDK 7, метод close() определяется в интерфейсе АutоСlоsеаblе из пакета java.lang. Интерфейс * АutоСlовеаblе* наследует от интерфейса Closeable из пакета java.io. Оба интерфейса реализуются классами потоков ввода-вывода, включая классы FileinputStream и FileOutputStream.

Чтобы прочитать данные из файла, можно воспользоваться формой метода read(), определенной в классе FileInputStream. Та его форма, которая применяется в представленных далее примерах, выглядит следующим образом:

```html
int read() throws IOException
```

Всякий раз, когда вызывается метод read(), он выполняет чтение одного байта из файла и возвращает ero в виде целочисленного значения. А если достигнут конец файла, то возвращается значение -1. Этот метод может сгенерировать исключение типа IOException.

В приведенном ниже примере программы метод read() применяется для ввода из файла, содержащего текст в коде ASCII, который затем выводится на экран. Имя файла указывается в качестве аргумента командной строки.

```html
java ShowFile TEST.txt
```

[Chapter13/Package02/ShowFile - Отображение содержимого текстового файла](https://github.com/Vladlena2/BookJava/blob/main/Chapter13/Package02/ShowFile.java "Посмотреть пример Java")
       

Иногда проще заключить все части программы, открывающие файл и получающие доступ к его содержимому, в один блок оператора try, вместо того чтобы разделять его на два блока, а затем закрыть файл в блоке оператора finally. В качестве иллюстрации ниже показан другой способ написания программы

[Chapter13/Package02/ShowFile2 - ShowFile из предыдущего примера.](https://github.com/Vladlena2/BookJava/blob/main/Chapter13/Package02/ShowFile2.java "Посмотреть пример Java")

[Chapter13/Package02/ShowFile3 - Отображение содержимого текстового файла в одном блоке оператора try](https://github.com/Vladlena2/BookJava/blob/main/Chapter13/Package02/ShowFile3.java "Посмотреть пример Java")

Класс исключения FileNotFoundException является производным от класса IOException, и поэтому обрабатывать отдельно его исключение совсем не обязательно. В качестве примера ниже приведена переделанная последовательность операторов try/catch без перехвата исключения типа FileNotFoundException. В данном случае отображается стандартное сообщение об исключительной ситуации, описывающее возникшую ошибку.

[Chapter13/Package02/ShowFile4 - Переделанная последовательность операторов try/catch](https://github.com/Vladlena2/BookJava/blob/main/Chapter13/Package02/ShowFile4.java "Посмотреть пример Java")

Для записи в файл можно воспользоваться методом writе(), определенным в классе FileOutputStream. В своей простейшей форме этот метод выглядит следующим образом:

```html
void write(int байтовое_значение) throws IOException
```

Этот метод записывает в файл байт, переданный ему в качестве параметра байтовое_значение. Несмотря на то что параметр байтовое_значение объявлен как целочисленный, в файл записываются только его младшие восемь бит. Если при записи возникает ошибка, генерируется исключение типа IOException. В следующем примере программы метод writе() применяется для копирования файла.

Обратите внимание на то, что в данном примере программы при закрытии файлов используются два отдельных блока оператора try. Этим гарантируется, что оба файла будут закрыты, даже если при вызове метода fin.close() будет сгенерировано исключение.

[Chapter13/Package02/CopyFile - Копирование файла](https://github.com/Vladlena2/BookJava/blob/main/Chapter13/Package02/CopyFile.java "Посмотреть пример Java")

Исключения в Java не только упрощают обращение с файлами, но и позволяют легко отличать условие достижения конца файла от ошибок во время ввода в файл.

</details>

<details><summary>Автоматическое закрытие файла</summary>

В версии JDK 7 появилась новая возможность, предлагающая иной способ управления такими ресурсами, как потоки
ввода-вывода в файлы: *автоматическое завершение процесса*. Эту возможность иногда еще называют
**автоматическим управлением ресурсами (ARM)**, и основывается она на усовершенствованной версии оператора try. Главное
преимущество автоматического
управления ресурсами заключается в предотвращении ситуаций, когда файл (или другой ресурс) не освобождается по
невнимательности, если он больше не нужен.

Запомните: если забыть по какой-нибудь причине закрыть файл, это может привести к утечке памяти и другим осложнениям.
Ниже приведена *усовершенствованная* форма оператора try.
```java
try (спецификация_ресурса) {
     // использование ресурса
}
```

Здесь *спецификация_ресурса*, как правило, обозначает оператор, объявляющий и инициализирующий такой ресурс, как *поток
ввода-вывода данных в файл*.

Он состоит из объявления переменной, где переменная инициализируется ссылкой на управляемый объект. По завершении блока
оператора try ресурс автоматически освобождается. Для файла это означает, что он автоматически закрывается, а
следовательно, отпадает необходимость вызывать метод close() явным образом.
Она называется оператором try с *ресурсами*.

Оператор try с ресурсами можно применять лишь вместе с теми ресурсами, в которых реализован интерфейс AutoCloseaЬle,
определенный в пакете java.lang. В этом интерфейсе определен метод close(), а наследует он от интерфейса Closeable из
пакета java.io. Оба интерфейса реализуются классами потоков ввода-вывода. Таким образом, оператор try с ресурсами
можно
применять для работы с потоками ввода и вывода, в том числе и в файлы.

[Chapter13/Package02/ShowFileAutoClose - Пример оператора try с ресурсами](https://github.com/Vladlena2/BookJava/blob/master/Chapter13/Package02/ShowFileAutoClose.java "Посмотреть пример Java")

Ресурс, объявляемый в операторе try, неявно считается конечным. Это означает, что присвоить ресурс после того, как он
был создан, нельзя. Кроме того, область действия ресурса ограничивается пределами оператора try с ресурсами.

В одном операторе try можно организовать управление несколькими ресурсами. Для этого достаточно указать спецификацию
каждого ресурса через точку с запятой. Примером тому служит приведенная ниже версия программы CopyFile, переделанная
таким образом, чтобы использовать один оператор try с ресурсами для управления переменными fin и fout.

[Chapter13/Package02/CopyFileAutoClose - Пример оператора try с двумя ресурсами](https://github.com/Vladlena2/BookJava/blob/master/Chapter13/Package02/CopyFileAutoClose.java "Посмотреть пример Java")

У оператора *try с ресурсами* имеется еще одна особенность, о которой стоит упомянуть. Когда выполняется блок оператора
try, существует вероятность того, что исключение, возникающее в блоке оператора try, приведет к другому исключению,
которое произойдет в тот момент, когда ресурс закрывается
в блоке оператора finally. Если это обычный оператор try, то первоначальное исключение теряется, будучи вытесненным
вторым исключением. А если используется оператор try с ресурсами, то второе исключение подавляется, но не теряется.
Вместо этого оно добавляется в список подавленных исключений, связанных
с первым исключением. Доступ к списку подавленных исключений может быть пол учен с помощью метода gеtSupprеssеd(),
определенного в классе Throwаblе.
</details>

<details><summary>Чтение и запись файлов. FileInputStream и FileOutputStream</summary>

**Запись файлов и класс FileOutputStream**

Класс *FileOutputStream* предназначен для записи байтов в файл. Он является производным от класса OutputStream, поэтому
наследует всю его функциональность.
Через конструктор класса FileOutputStream задается файл, в который производится запись. Класс поддерживает несколько
конструкторов:
```java
FileOutputStream(String filePath)
FileOutputStream(File fileObj)
FileOutputStream(String filePath, boolean append)
FileOutputStream(File fileObj, boolean append)
```
Файл задается либо через строковый путь, либо через объект File. Второй параметр - append задает способ записи: eсли он
равен true, то данные дозаписываются в конец файла, а при false - файл полностью перезаписывается.  
Например, запишем в файл строку:

[Chapter13/Package02/WriteFile - Пример записи строки в файл TEST.txt](https://github.com/Vladlena2/BookJava/blob/master/Chapter13/Package02/WriteFile.java "Посмотреть пример Java")

Для создания объекта FileOutputStream используется конструктор, принимающий в качестве параметра путь к файлу для
записи. Если такого файла нет, то он автоматически создается при записи. Так как здесь записываем строку, то ее надо
сначала перевести в массив байтов. И с помощью метода write строка записывается в файл.
При этом необязательно записывать весь массив байтов. Используя перегрузку метода write(), можно записать и одиночный
байт:
```java
fos.write(buffer[0]); // запись первого байта
```

**Чтение файлов и класс FileInputStream**

Для считывания данных из файла предназначен класс *FileInputStream*, который является наследником класса InputStream и
поэтому реализует все его методы.

Для создания объекта FileInputStream мы можем использовать ряд конструкторов. Наиболее используемая версия конструктора
в качестве параметра принимает путь к считываемому файлу:
```java
FileInputStream(String fileName) throws FileNotFoundException
```
Если файл не может быть открыт, например, по указанному пути такого файла не существует, то генерируется исключение *
FileNotFoundException*.  
Считаем данные из ранее записанного файла (TEST.txt) и выведем на консоль:

[Chapter13/Package02/ReadFile - Пример чтения файла TEST.txt](https://github.com/Vladlena2/BookJava/blob/master/Chapter13/Package02/ReadFile.java "Посмотреть пример Java")

В данном случае мы считываем каждый отдельный байт в переменную i:
```java
while((i = fin.read()) != -1) {
```
Когда в потоке больше нет данных для чтения, метод возвращает число -1.
Затем каждый считанный байт конвертируется в объект типа char и выводится на консоль.  
Подобным образом можно считать данные в массив байтов и затем производить с ним манипуляции:
```java
byte[] buffer = new byte[fin.available()];
// считаем файл в буфер
fin.read(buffer, 0, fin.available());

System.out.println("File data:");
for(int i=0; i<buffer.length;i++){
    System.out.print((char)buffer[i]);
}
```

Совместим оба класса и выполним чтение из одного и запись в другой файл:

[Chapter13/Package02/ReadWriteFile - Пример чтение из одного и запись в другой файл](https://github.com/Vladlena2/BookJava/blob/master/Chapter13/Package02/ReadWriteFile.java "Посмотреть пример Java")

Классы FileInputStream и FileOutputStream предназначены прежде всего для записи двоичных файлов, то есть для записи и
чтения байтов. И хотя они также могут использоваться для работы с текстовыми файлами, но все же для этой задачи больше
подходят другие классы.

Еще один пример, в котором создаем для записи файл, далее записываем в него строку.  
Потом читаем и выводим на конслоь данные из этого файла и все это копируем в новый файл.

[Chapter13/Package02/WriteReadSaveToFile - Создание, чтение одного файла и копирование в другой файл](https://github.com/Vladlena2/BookJava/blob/master/Chapter13/Package02/WriteReadSaveToFile.java "Посмотреть пример Java")
</details>

<details><summary>Чтение и запись текстовых файлов. Класс FileWriter. Класс FileReader</summary>

Для полноценной работы с текстовыми файлами служат совсем другие классы, которые являются наследниками абстрактных
классов *Reader* и *Writer*.

Класс *FileWriter* является производным от класса *Writer*. Он используется для записи текстовых файлов.
Чтобы создать объект *FileWriter*, можно использовать один из следующих конструкторов:
```
FileWriter(File file)
FileWriter(File file, boolean append)
FileWriter(FileDescriptor fd)
FileWriter(String fileName)
FileWriter(String fileName, boolean append)
```  
Так, в конструктор передается либо путь к файлу в виде строки, либо объект File, который ссылается на конкретный
текстовый файл. Параметр *append* указывает, должны ли данные дозаписываться в конец файла (если параметр равен true),
либо файл должен перезаписываться.

Класс *FileReader* наследуется от абстрактного класса *Reader* и предоставляет функциональность для чтения текстовых
файлов.
Для создания объекта *FileReader* мы можем использовать один из его конструкторов:
```java
FileReader(String fileName) 
FileReader(File file)
FileReader(FileDescriptor fd)
```  

[Chapter13/Package02/FileWriterReaderDemo - Записать текст в файл и прочитать](https://github.com/Vladlena2/BookJava/blob/master/Chapter13/Package02/FileWriterReaderDemo.java "Посмотреть пример Java")
</details>

<details><summary>Модификаторы доступа transient и volatile</summary>

В языке J ava определяются два интересных модификатора доступа: *transient* и *volatile*. Эти модификаторы
предназначены для особых случаев. Когда переменная-экземпляр объявлена как transient, ее значение не должно
сохраняться, когда сохраняется объект, как показано ниже.

```java
class T {
    transient int а; //не сохранится
    int b; // сохранится
} 
```

Если в данном примере кода объект типа т записывается в область постоянного хранения, то содержимое переменной а не
должно сохраняться, тогда как содержимое переменной b должно быть сохранено.

Модификатор доступа volatile сообщает компилятору, что модифицируемая им переменная может быть неожиданно изменена в
других частях программы.
Одна из таких ситуаций возникает в многопоточных программах, где иногда в двух или больше потоках исполнения
разделяется
общая переменная. Из соображений эффективности в каждом потоке может храниться своя закрытая копия этой
переменной. Настоящая (или главная) копия переменной обновляется в разные моменты, например при входе в
синхронизированный метод. Такой подход вполне работоспособен, но не всегда оказывается достаточно эффективным. Иногда
требуется, чтобы главная копия переменной постоянно отражала ее текущее состояние. И для этого достаточно объявить
переменную как volatile, предписав тем самым компилятору всегда использовать главную копию этой переменной
(или хотя бы поддерживать любые закрытые ее копии обновляемыми по главной копии, и наоборот). Кроме того, доступ к
главной копии переменной должен осуществляться в том порядке, в каком он определен в самой программе.

[Chapter13/Package03/InstanceOf - Продемонстрировать применение операции instanceof](https://github.com/Vladlena2/BookJava/blob/master/Chapter13/Package03/InstanceOf.java "Посмотреть пример Java")
</details>

<details><summary>Применение операции instanceof</summary>

Иногда тип объекта полезно выяснить во время выполнения. Например, в одном потоке исполнения объекты разных типов могут
формироваться, а в другом потоке исполнения - использоваться. В таком случае удобно выяснить тип каждого объекта,
получаемого в обрабатывающем потоке исполнения. Тип объекта во время выполнения не менее важно выяснить и в том
случае,
когда требуется приведение типов. В языке Java неправильное приведение типов влечет за собой появление ошибок во время
выполнения.

Для разрешения этого вопроса в Java предоставляется операция времени выполнения *instanceof*, которая имеет следующую
общую форму:
```java
ссылка_на_объект instanceof тип
```   
Здесь *ссылка_на_объект* обозначает ссылку на экземпляр класса, а тип - конкретный тип этого класса. Если *
ссылка_на_объект* относится к указанному типу или может быть приведена к нему, то вычисление операции *instanceof*
дает
в итоге логическое значение *true*, а иначе - логическое значение *false*. Таким образом, операция *instanceof* - это
средство, с помощью которого программа может получить сведения об объекте во время выполнения.

</details>

<details><summary>Модификатор доступа strictfp</summary>

Объявляя класс, метод или интерфейс с модификатором доступа *strictfp*, можно гарантировать, что вычисления с плавающей
точкой будут выполняться таким же образом, как и в первых версиях Java. Если класс объявляется с модификатором
доступа *
strictfp*, все его методы автоматически модифицируются как *strictfp*.

Например, в приведенной ниже строке кода компилятору Java сообщается, что во всех методах, определенных в классе
MyClass, следует использовать исходную модель вычислений с плавающей точкой. Откровенно говоря, большинству
программистов вряд ли понадобится модификатор доступа *strictfp*, поскольку он касается лишь небольшой категории
задач.
```java
strictfp class MyClass { // ...
``` 

</details>

<details><summary>Платформенно-ориентированные методы</summary>

Иногда, хотя и редко, возникает потребность вызвать подпрограмму, написанную на другом языке, а не на Java. Как
правило, такая подпрограмма существует
в виде исполняемого кода для ЦП и той среды, в которой приходится работать, т.е. в виде платформенно-ориентированного
кода. Такую подпрограмму, возможно, потребуется вызвать для повышения скорости ее выполнения. С другой стороны, может
возникнуть потребность работать со специализированной сторонней библиотекой, например с пакетом статистических
расчетов.

Для объявления платформенно-ориентированных методов в Java предусмотрено ключевое слово *native*. Однажды объявленные
как *native*, эти методы могут быть вызваны из прикладной программы на Java таким же образом,
как и любой другой метод. Механизм, применяемый для внедрения платформенно-ориентированного кода в прикладные
программы
на Java, называется JNI (*Java Native Interface - платформенно-ориентированный интерфейс Java*).

Чтобы объявить платформенно-ориентированный метод, его имя следует предварить модификатором доступа *native*, но не
определять тело метода, как показано ниже.
```java
public native int meth();
```
Объявив платформенно-ориентированный метод, необходимо написать его и предпринять ряд относительно сложных шагов, чтобы
связать его с кодом Java. Большинство платформенно-ориентированных методов пишутся на С.

</details>

<details><summary>Применение ключевого слова assert</summary>

Ключевое слово *assert* используется на стадии *разработки* программ для создания так называемых утверждений - условий,
которые должны быть *истинными* во время выполнения программы. Если во время выполнения программы условие оказывается
истинным, то никаких действий больше не выполняется. Но если условие окажется ложным, то генерируется исключение
типа *
AssertionError*. Утверждения часто применяются с целью проверить, действительно ли выполняется некоторое ожидаемое
условие. В коде окончательной версии программы утверждения, как правило, отсутствуют.

Ниже приведен пример программы, демонстрирующий применение оператора *assert*. В этом примере проверяется, возвращает
ли метод getnum() положительное значение.

[Chapter13/Package03/AssertDemo - Продемонстрировать применение оператора assert](https://github.com/Vladlena2/BookJava/blob/master/Chapter13/Package03/AssertDemo.java "Посмотреть пример Java")

Для правильного понимания утверждений очень важно иметь в виду следующее: на них нельзя полагаться для выполнения
каких-нибудь конкретных действий в программе. Дело в том, что отлаженный код окончательной версии программы будет
выполняться с *отключенным* режимом проверки утверждений.

Благодаря утверждениям, строки кода с оператором *assert* можно не удалять из окончательного варианта кода программы.

**Параметры включения и отключения режима проверки утверждений.**

Чтобы *включить* режим проверки утверждений в пакете MyPack, достаточно ввести следующее:
```
-ea:MyPack ...
```

Чтобы *отключить* режим проверки утверждений, следует ввести:
```
-da:MyPack ...
```

Кроме того, класс можно указать с параметром -еа или -da. В качестве примера ниже показано, как включить режим проверки
утверждений отдельно в классе AssertDemo.
```
-ea:AssertDemo
``` 
</details>

<details><summary>Статический импорт</summary>

В языке Java имеется языковое средство, расширяющее возможности ключевого слова import и называемое *статическим
импортом*. Оператор import, предваряемый ключевым словом static, можно применять для импорта статических членов класса
или интерфейса. Благодаря статическому импорту появляется возможность ссылаться на статические члены непосредственно
по
именам, не уточняя их именем класса. Это упрощает и сокращает синтаксис, требующийся для работы со статическими
членами.
```java
// Вычислить длину гипотенузы прямоугольного треугольника
...
// Имена методов уточнены именем их класса Math
hypot = Math.sqrt(Math.pow(sidel, 2) + Math.pow(side2, 2));
...

// Используем статический импортом для доступ к встроенным в Java методам
import static java.lang.Mat.*;

...
// Здесь методы sqrt() и pow() можно вызывать непосредственно, опуская имя их Класса 
hypot = sqrt(pow(sidel, 2) + pow(side2, 2)); 
...

```
*Статический импорт* следует применять на тот случай, если статические члены применяются многократно, в частности при
выполнении целого ряда математических вычислений. В сущности, этим языковым средством стоит пользоваться, но только не
злоупотреблять им.
</details>

<details><summary>Вызов перегружаемых конструкторов по ссылке this()</summary>

Пользуясь *перегружаемыми конструкторами*, иногда удобно вызывать один конструктор из другого. Для этого в Java имеется
еще одна форма ключевого слова this. В общем виде эта форма выглядит следующим образом:
```java
this(список_аргументов)
```
По ссылке this() сначала выполняется *перегружаемый конструктор*, который соответствует заданному *списку_аргументов*,
а затем - любые операторы, находящиеся в теле исходного конструктора, если таковые имеются. Вызов конструктора по
ссылке
this() должен быть *первым* оператором в конструкторе.
Рассмотрим сначала приведенный ниже пример класса, в котором ссылка this() *не употребляется*.

Этот класс содержит три конструктора, каждый из которых инициализирует значения полей а и b. Первому конструктору
передаются отдельные значения для инициализации полей а и b. Второй конструктор принимает только одно значение и
присваивает его обоим полям, а и b. А третий присваивает полям а и b нулевое значение по умолчанию.
```java
class MyClass {
   int a;
   int b;
   // инициализировать поля а и b по отдельности
   MyClass(int i, int j) {
        a = i;
       b = j;    
    }
   // присвоить полям а и b нулевое значение по умолчанию
    MyClass() {
     a = 0;
      b = 0;
    }   
}
```

Используя ссылку this(), приведенный выше класс MyClass можно переписать следующим образом. В данной версии класса
MyClass значения непосредственно присваиваются полям а и b только в конструкторе MyClass (int, int). А два других
конструктора просто вызывают первый конструктор (прямо или косвенно) по ссылке this().
```java
class MyClass {
    int a;
    int b;
    // инициализировать поля а и b по отдельности
   MyClass(int i, int j) {
       a = i;
        b = j;    
    }
    // инициализировать поля а и b одним и тем же значением
   MyClass(int i) {
       this(i, i); // по этой ссылке вызывается конструктор MyClass(i, i);
    }


    // присвоить полям а и b нулевое значение по умолчанию
    MyClass() {
        this(0); // по этой ссылке вызывается конструктор MyClass(O)
  }   
}
```  
Одной из причин, по которой стоит вызывать перегружаемые конструкторы по ссылке this(),служит потребность избежать
дублирования кода. Зачастую сокращение дублированного кода ускоряет загрузку классов, поскольку объектный
код становится компактнее. Это особенно важно для программ, доставляемых через Интернет, когда время их загрузки
критично. Применение ссылки this() позволяет также оптимально структурировать прикладной код, когда конструкторы
содержат большой объем дублированного кода.

Следует также иметь в виду, что вызов очень коротких конструкторов, как, например, из класса MyClass, по ссылке this()
зачастую лишь незначительно увеличивает размер объектного кода. (В некоторых случаях никакого уменьшения объема
объектного кода вообще не происходит.) Дело в том, что байт-код, который устанавливается и возвращается из вызова
конструктора по ссылке this(), добавляет инструкции в объектный файл. Поэтому в таких случаях вызов конструктора по
ссылке this(), несмотря на исключение дублирования кода, не даст значительной экономии времени загрузки, но может
повлечь за собой дополнительные издержки на создание каждого объекта. Поэтому ссылка this() больше всего подходит для
вызова тех конструкторов, которые содержат большой объем кода инициализации, а не тех, которые просто устанавливают значения в нескольких полях.

Вызывая конструкторы по ссылке this(), следует учитывать следующее. Вопервых, при вызове конструктора по ссылке
this() *нельзя* использовать переменные экземпляра класса этого конструктора. И, во-вторых, в одном и том же
конструкторе *нельзя* использовать ссылки super() и this(), поскольку каждая из них должна быть первым оператором в
конструкторе.
</details>

<details><summary>Компактные профили Java API</summary>

В версии JDK 8 внедрено средство, позволяющее организовать подмножества
библиотеки прикладных программных интерфейсов API в так называемые *компактные профили*. Они обозначаются следующим
образом: *compact1, compact2 и cornpactЗ*. Каждый такой профиль содержит подмножество библиотеки. Более того,
компактный
профиль *compact2* включает в себя весь профиль *compact1*, а компактный профиль *compactЗ* - весь профиль *compact2*.
Следовательно, каждый последующий компактный профиль строится на основании предыдущего. Преимущество компактных
профилей
заключается в том, что прикладной
программе не нужно загружать библиотеку полностью. Применение компактных профилей позволяет сократить размер
библиотеки,
а следовательно, выполнять некоторые категории прикладных программ на тех устройствах, где отсутствует полная
поддержка
прикладного программного интерфейса Java API. Благодаря компактным профилям удается также сократить время, требующееся
для загрузки программы. В документации на прикладной программный интерфейс Java API
версии JDK 8 указывается, к какому именно элементу этого прикладного интерфейса принадлежит компактный профиль, если
это
вообще имеет место. Следует, однако, иметь в виду, что в версии JDK 9 на смену компактным профилям пришли внедренные в
ней модули.
</details>

</blockquote>
</details>

</blockquote>
</details>
