## Книга "Java полное руководство - Герберт Шилдт, 12-е издание, 2022г."

<small>

#### Оглавление

<details ГЛАВА 13><summary>ГЛАВА 13. "Ввод-вывод, оператор try с ресурсами и др."</summary>
<blockquote>

<details><summary>Ввод-вывод</summary>

Поддержка ввода-вывода обеспечивается основными библиотеками Java API, а не системными библиотеками языка.

<details><summary>Потоки данных</summary>

Ввод и вывод данных в Java-программах осуществляется через потоки данных. Поток данных - это абстракция, которая может производить или потреблять информацию. Поток связывается с физическим устройством посредством системы ввода-вывода Java. Классы и методы ввода-вывода можно применять к различным типам устройств, таким как дисковые файлы, клавиатура или сетевые соединения. Это позволяет абстрагироваться от множества различных видов ввода. Вывод данных может осуществляться на консоль, в дисковый файл или по сетевому соединению. Потоки данных в Java реализованы в иерархиях классов, определенных в пакете java.io.

Java также предоставляет ввод-вывод на основе буферов и каналов, которые определены в пакете java.nio и его подпакетах.

</details>

<details><summary>Потоки байтовых и символьных данных</summary>

В Java существуют два типа потоков ввода/вывода: байтовые и символьные. Байтовые потоки удобны для обработки ввода и вывода байтовых данных, например при чтении или записи двоичных данных. Символьные потоки используют Unicode и позволяют обрабатывать ввод и вывод символов, обеспечивая поддержку интернационализации. В некоторых случаях символьные потоки более эффективны, чем байтовые.

На самом низком уровне операции ввода-вывода по-прежнему выполняются с байтами. Символьные потоки предоставляют удобный и эффективный способ работы со символами в кодировке Unicode.
  
</details>

<details><summary>Классы потоков байтовых данных</summary>

**Классы потоков ввода-вывода байтов из пакета java.io**

Потоки ввода-вывода байтов определены в двух иерархиях классов. На вершине этих иерархий находятся _абстрактные классы InputStream и OutputStream_. У каждого из этих абстрактных классов имеется несколько конкретных подклассов, в которых учитываются отличия разных устройств, в том числе файлов на диске, сетевых соединений и даже буферов памяти.

```html
BufferedInputStream    Буферизованный поток ввода  
BufferedOutputStream   Буферизованный поток вывода  
ByteArrayinputStream   Поток ввода, читающий байты из массива  
ByteArrayOutputStream  Поток вывода, записывающий байты в массив  
DataInputStream        Поток ввода, содержащий методы для чтения данных стандартных типов, определенных в Java  
DataOutputStream       Поток вывода, содержащий методы для записи данных стандартных типов, определенных в Java  
FileInputStream        Поток ввода, читающий данные из файла  
FileOutputStream       Поток вывода, записывающий данные в файл  
FilterInputStream      Реализует абстрактный класс InputStream  
FilterOutputStream     Реализует абстрактный класс OutputStream  
InputStream            Абстрактный класс, описывающий поток ввода  
ObjectInputStream      Поток ввода объектов  
ObjectOutputstream     Поток вывода объектов  
OutputStream           Абстрактный класс, описывающий поток вывода  
PipedInputStream       Канал ввода  
PipedOutputstream      Канал вывода  
PrintStream            Поток вывода, содержащий методы print() и println()  
PushbackInputStream    Поток ввода, поддерживающий возврат одного байта обратно в поток ввода  
SequenceInputStream    Поток ввода, состоящий из нескольких потоков ввода, данные из которых читаются по очереди  
```

В абстрактных классах InputStream и OutputStream определяется ряд ключевых методов, реализуемых в других классах потоков ввода-вывода. Наиболее важными среди них являются методы read() и writе(), читающие и записывающие байты данных соответственно. Оба эти метода объявлены как абстрактные в классах InputStream и OutputStream, а в производных классах они переопределяются.

**Классы потоков ввода-вывода символов**

Потоки ввода-вывода символов также определены в двух иерархиях классов. На вершине этих иерархий находятся два * абстрактных* класса - Reader и Writer. Эти абстрактные классы управляют потоками символов в Юникоде. Для каждого из них в Java предусмотрен ряд конкретных подклассов.

```html
BufferedReader         Буферизированный поток ввода символов  
BufferedWriter         Буферизированный поток вывода символов  
CharArrayReader        Поток ввода, читающий символы из массива  
CharArrayWriter        Поток вывода, записывающий символы в массив  
FileReader             Поток ввода, читающий символы из файла  
FileWriter             Поток вывода, записывающий символы в файл  
FilterReader           Фильтрованный поток чтения  
FilterWriter           Фильтрованный поток запис  
InputStreamReader      Поток ввода, преобразующий байты в символы  
LineNumЬerReader       Поток ввода, подсчитывающий строки  
OutputStreamWriter     Поток вывода, преобразующий символы в байты  
PipedReader            Канал ввода  
PipedWriter            Канал вывода  
PrintWriter            Поток вывода, содержащий методы print() и println()  
PushbackReader         Поток ввода, позволяющий возвращать символы обратно в поток ввода  
Reader                 Абстрактный класс, описывающий поток ввода символов  
StringReader           Поток ввода, читающий символы из строки  
StringWriter           Поток вывода, записывающий символы в строку  
Writer                 Абстрактный класс, описывающий поток вывода символов   
```

В абстрактных классах Reader и Writer определяется ряд ключевых методов, реализуемых в других классах потоков ввода-вывода. Наиболее важными среди них являются методы read() и write(), читающие и записывающие байты данных соответственно. Оба эти метода объявлены как абстрактные в классах Reader и Writer, а в производных классах они переопределяются.

</details>

<details><summary>Предопределенные потоки данных</summary>

Класс System содержит несколько методов для получения информации о системе и текущего времени, а также три предопределенных потоковых переменных: in, out и err, которые могут быть использованы в любой части программы без привязки к конкретному экземпляру класса System.

Переменная System.out ссылается на поток стандартного вывода, по умолчанию вывод осуществляется на консоль. System.in ссылается на поток стандартного ввода, по умолчанию принимаемые данные поступают с клавиатуры. System.err ссылается на поток вывода ошибок, также по умолчанию вывод ошибок осуществляется на консоль. Эти потоки могут быть перенаправлены на другие устройства ввода-вывода, поддерживающие совместимые форматы данных.

System.in, System.out и System.err являются потоками байтовых данных типа InputStream, PrintStream и ErrorStream соответственно. Однако они обычно используются для чтения и записи символов в консоль. Вы можете использовать их как основу для более сложных операций ввода-вывода или обернуть их в классы символьных потоков для дополнительной гибкости и контроля.

</details>

<details><summary>Чтение консольного ввода</summary>

История Java и консольный ввод:
   - На заре развития Java единственным способом выполнения консольного ввода было использование потока байтовых данных.
   - В настоящее время символьный поток предпочтительнее из-за удобства интернационализации и сопровождения программы.

Java 17 и изменения:
   - В JDK 17 изменился способ получения объекта InputStreamReader, связанного с System.in.
   - Рекомендуется явно указывать набор символов, ассоциированный с консолью, при создании InputStreamReader. Набор символов определяет способ сопоставления байтов с символами. Обычно, когда набор символов не задан, применяется стандартная кодировка 
JVM.

Использование InputStreamReader и BufferedReader:
   - Для чтения консольного ввода через BufferedReader, рекомендуется использовать конструктор InputStreamReader с явным указанием набора символов, ассоциированного с консолью.
   - Можно использовать метод System.console() для получения объекта Console и его метод charset() для получения набора символов консоли.

Создание BufferedReader с использованием InputStreamReader без явного указания набора символов (до JDK 17):

```html
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class ConsoleInputExample {
    public static void main(String[] args) {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        try {
            System.out.print("Введите ваше имя: ");
            String name = br.readLine();
            System.out.println("Привет, " + name + "!");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

Создание BufferedReader с использованием InputStreamReader с явным указанием набора символов (начиная с JDK 17):
 
```html
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.Charset;

public class ConsoleInputExample {
    public static void main(String[] args) {
        InputStreamReader isr = new InputStreamReader(System.in, Charset.defaultCharset());
        BufferedReader br = new BufferedReader(isr);

        try {
            System.out.print("Введите ваше имя: ");
            String name = br.readLine();
            System.out.println("Привет, " + name + "!");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

Современный подход к чтению консольного ввода в Java включает явное указание набора символов консоли при создании InputStreamReader, что обеспечивает более надежное и удобное взаимодействие с консолью в различных приложениях.

</details>

<details><summary>Чтение символов</summary>

Чтобы получить поток ввода символов, присоединив его к консоли, следует заключить стандартный поток ввода System.in в оболочку объекта класса BufferedReader, поддерживающего буферизованный поток ввода. Ниже приведен чаще всего используемый конструктор этого класса.

```html
BufferedReader(Reader поток_чтения_вводимых_данных)  
```

десь параметр поток_чтения_вводимых_данных обозначает поток, который связывается с создаваемым экземпляром класса BufferedReader. Класс Reader является абстрактным. Одним из производных от него конкретных подклассов является класс InputStreamReader, преобразующий байты в символы. Для получения объекта типа InputStreamReader, связанного со стандартным потоком ввода System.in, служит следующий конструктор:

```html
InputStreamReader(InputStream поток_ввода)   
```

Переменная System.in ссылается на объект класса InputStream и поэтому должна быть указана в качестве параметра поток_ввода. В конечном итоге получается приведенная ниже строка кода, где создается объект типа BufferedReader, связанный с клавиатурой. После выполнения этой строки кода переменная экземпляра br будет содержать поток ввода символов, связанный с консолью через стандартный поток ввода System.in.

```html
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
```

Для чтения символа из потока ввода типа BufferedReader служит метод read(). Ниже приведена общая форма метода read().

```html
int read() throws IOException  
```

Всякий раз, когда метод read() вызывается, он читает символ из потока ввода и возвращает его в виде целочисленного значения. По достижении конца потока возвращается значение -1. Как видите, метод read() может сгенерировать исключение типа IOException.

[Chapter13/Package01/BRRead - Использовать класс BufferedReader для чтения символов с консоли](https://github.com/Vladlena2/BookJava2/blob/main/Chapter13/Package01/BRRead.java "Посмотреть пример Java")

Для чтения символьных строк с клавиатуры служит версия метода readLine(), который является членом класса BufferedReader. Его общая форма приведена ниже. Как видите, этот метод возвращает объект типа String.

```html
String readLine() throws IOException    
```

[Chapter13/Package01/BRReadLines - Чтение символьных строк с консоли средствами класса BufferedReader](https://github.com/Vladlena2/BookJava2/blob/main/Chapter13/Package01/BRReadLines.java "Посмотреть пример Java")

В следующем далее примере программы демонстрируется простейший текстовый редактор. С этой целью сначала создается массив объектов типа String, а затем читаются текстовые строки, каждая из которых сохраняется в элементе массива. Чтение производится до 100 строк или до тех пор, пока не будет введено слово "стоп". Для чтения данных с консоли применяется класс BufferedReader.

[Chapter13/Package01/TinyEdit - Простейший текстовый редактор](https://github.com/Vladlena2/BookJava2/blob/main/Chapter13/Package01/TinyEdit.java "Посмотреть пример Java")

</details>

<details><summary>Запись данных, выводимых на консоль</summary>

Вывод данных на консоль проще всего организовать с помощью упоминавшихся ранее методов print() и println(). Эти методы определены в классе PrintStream (он является типом объекта, на который ссылается переменная System.out).

Класс PrintStream описывает поток вывода и является производным от класса OutputStream, поэтому в нем реализуется также низкоуровневый метод write(). Следовательно, метод write() можно применять для записи данных, выводимых на консоль. Ниже приведена простейшая форма метода writе(), определенного в классе PrintStream.

```html
void write(int байтовое_значение)     
```

Этот метод записывает байт, передаваемый в качестве параметра байтовое_значение. Несмотря на то что параметр * байтовое_значение* объявлен как целочисленный, записываются только 8 его младших бит. Ниже приведен короткий пример программы, где метод write() применяется для вывода на экран буквы "А" с последующим переводом строки.

```html
// Продемонстрировать применение метода System.out.write()
class WriteDemo {
   public static void main(String[] args){
       int b;
       b = 'A';
       System.out.write(b);
       System.out.print("\n");
   }
}   
```

**Класс PrintWriter**

Применение класса PrintWriter для консольного вывода упрощает интернационализацию прикладных программ. В классе PrintWriter определяется несколько конструкторов. Ниже приведен один из тех конструкторов:

```html
PrintWriter(OutputStream поток_вывода, boolean очистка)   
```

Здесь параметр поток_вывода обозначает объект типа OutputStream, а параметр очистка - очистку потока вывода всякий раз, когда вызывается (среди прочих) метод println(). Если параметр очистка принимает логическое значение true, то очистка потока вывода происходит автоматически, а иначе - вручную.

В классе PrintWriter поддерживаются методы print() и println(). Следовательно, их можно использовать таким же образом, как и в стандартном по токе вывода System.out. Если аргумент этих методов не относится к простому типу, то для объекта типа PrintWriter сначала вызывается метод toString(), а затем выводится результат.

Чтобы вывести данные на консоль, используя класс PrintWriter, следует указать стандартный поток System.out для вывода и его автоматическую очистку. Например, в следующей строке кода создается объект типа PrintWriter, который связывается с консольным выводом:

```html
PrintWriter pw = new PrintWriter(System.out, true);
```

[Chapter13/Package01/PrintWriterDemo - Продемонстрировать применение класса PrintWriter](https://github.com/Vladlena2/BookJava2/blob/main/Chapter13/Package01/PrintWriterDemo.java "Посмотреть пример Java")
       
</details>

<details><summary>Чтение файлов и запись в файлы</summary>

Для ввода-вывода данных в файлы чаще всего применяются классы FileInputStream и FileOutputStream, которые создают потоки ввода-вывода байтов, связанные с файлами. Чтобы открыть файл для ввода-вывода данных, достаточно создать объект одного из этих классов, указав имя файла в качестве аргумента конструктора. У обоих классов имеются и дополнительные конструкторы, но в представленных далее примерах будут употребляться только следующие конструкторы:

```html
FileInputStream(String имя_файла)
   throws FileNotFoundException
FileOutputStream(String имя_файла)
   throws FileNotFoundException
```

Здесь параметр имя_файла обозначает имя того файла, который требуется открыть. Если при создании потока ввода файл не существует, то генерируется исключение типа FileNotFoundException. А если при создании потока вывода файл нельзя открыть или создать, то и в этом случае генерируется исключение типа FileNotFoundException. Класс исключения FileNotFoundException является производным от класса IOException. Когда файл открыт для вывода, любой файл, существовавший ранее под тем же самым именем, уничтожается.

Завершив работу с файлом, его нужно закрыть. Для этой цели служит метод close(), реализованный в классах FileinputStream и F ileOutputStream:

```html
void close() throws IOException
```

Закрытие файла высвобождает выделенные для него системные ресурсы, позволяя использовать их для других файлов. Неудачный исход закрытия файла может привести к **"утечкам памяти"**, поскольку неиспользуемые ресурсы оперативной памяти останутся выделенными.

**На заметку!**

Начиная с версии JDK 7, метод close() определяется в интерфейсе АutоСlоsеаblе из пакета java.lang. Интерфейс * АutоСlовеаblе* наследует от интерфейса Closeable из пакета java.io. Оба интерфейса реализуются классами потоков ввода-вывода, включая классы FileinputStream и FileOutputStream.

Чтобы прочитать данные из файла, можно воспользоваться формой метода read(), определенной в классе FileInputStream. Та его форма, которая применяется в представленных далее примерах, выглядит следующим образом:

```html
int read() throws IOException
```

Всякий раз, когда вызывается метод read(), он выполняет чтение одного байта из файла и возвращает ero в виде целочисленного значения. А если достигнут конец файла, то возвращается значение -1. Этот метод может сгенерировать исключение типа IOException.

В приведенном ниже примере программы метод read() применяется для ввода из файла, содержащего текст в коде ASCII, который затем выводится на экран. Имя файла указывается в качестве аргумента командной строки.

```html
java ShowFile TEST.txt
```

[Chapter13/Package02/ShowFile - Отображение содержимого текстового файла](https://github.com/Vladlena2/BookJava2/blob/main/Chapter13/Package02/ShowFile.java "Посмотреть пример Java")
       

Иногда проще заключить все части программы, открывающие файл и получающие доступ к его содержимому, в один блок оператора try, вместо того чтобы разделять его на два блока, а затем закрыть файл в блоке оператора finally. В качестве иллюстрации ниже показан другой способ написания программы

[Chapter13/Package02/ShowFile2 - ShowFile из предыдущего примера.](https://github.com/Vladlena2/BookJava2/blob/main/Chapter13/Package02/ShowFile2.java "Посмотреть пример Java")

[Chapter13/Package02/ShowFile3 - Отображение содержимого текстового файла в одном блоке оператора try](https://github.com/Vladlena2/BookJava2/blob/main/Chapter13/Package02/ShowFile3.java "Посмотреть пример Java")

Класс исключения FileNotFoundException является производным от класса IOException, и поэтому обрабатывать отдельно его исключение совсем не обязательно. В качестве примера ниже приведена переделанная последовательность операторов try/catch без перехвата исключения типа FileNotFoundException. В данном случае отображается стандартное сообщение об исключительной ситуации, описывающее возникшую ошибку.

[Chapter13/Package02/ShowFile4 - Переделанная последовательность операторов try/catch](https://github.com/Vladlena2/BookJava2/blob/main/Chapter13/Package02/ShowFile4.java "Посмотреть пример Java")

Для записи в файл можно воспользоваться методом writе(), определенным в классе FileOutputStream. В своей простейшей форме этот метод выглядит следующим образом:

```html
void write(int байтовое_значение) throws IOException
```

Этот метод записывает в файл байт, переданный ему в качестве параметра байтовое_значение. Несмотря на то что параметр байтовое_значение объявлен как целочисленный, в файл записываются только его младшие восемь бит. Если при записи возникает ошибка, генерируется исключение типа IOException. В следующем примере программы метод writе() применяется для копирования файла.

Обратите внимание на то, что в данном примере программы при закрытии файлов используются два отдельных блока оператора try. Этим гарантируется, что оба файла будут закрыты, даже если при вызове метода fin.close() будет сгенерировано исключение.

[Chapter13/Package02/CopyFile - Копирование файла](https://github.com/Vladlena2/BookJava2/blob/main/Chapter13/Package02/CopyFile.java "Посмотреть пример Java")

Исключения в Java не только упрощают обращение с файлами, но и позволяют легко отличать условие достижения конца файла от ошибок во время ввода в файл.

</details>

<details><summary>Автоматическое закрытие файла</summary>

В версии JDK 7 появилась новая возможность, предлагающая иной способ управления такими ресурсами, как потоки
ввода-вывода в файлы: *автоматическое завершение процесса*. Эту возможность иногда еще называют
**автоматическим управлением ресурсами (ARM)**, и основывается она на усовершенствованной версии оператора try. Главное
преимущество автоматического
управления ресурсами заключается в предотвращении ситуаций, когда файл (или другой ресурс) не освобождается по
невнимательности, если он больше не нужен.

Запомните: если забыть по какой-нибудь причине закрыть файл, это может привести к утечке памяти и другим осложнениям.
Ниже приведена *усовершенствованная* форма оператора try.
```java
try (спецификация_ресурса) {
     // использование ресурса
}
```

Здесь *спецификация_ресурса*, как правило, обозначает оператор, объявляющий и инициализирующий такой ресурс, как *поток
ввода-вывода данных в файл*.

Он состоит из объявления переменной, где переменная инициализируется ссылкой на управляемый объект. По завершении блока
оператора try ресурс автоматически освобождается. Для файла это означает, что он автоматически закрывается, а
следовательно, отпадает необходимость вызывать метод close() явным образом.
Она называется оператором try с *ресурсами*.

Оператор try с ресурсами можно применять лишь вместе с теми ресурсами, в которых реализован интерфейс AutoCloseaЬle,
определенный в пакете java.lang. В этом интерфейсе определен метод close(), а наследует он от интерфейса Closeable из
пакета java.io. Оба интерфейса реализуются классами потоков ввода-вывода. Таким образом, оператор try с ресурсами
можно
применять для работы с потоками ввода и вывода, в том числе и в файлы.

[Chapter13/Package02/ShowFileAutoClose - Пример оператора try с ресурсами](https://github.com/Vladlena2/BookJava2/blob/master/Chapter13/Package02/ShowFileAutoClose.java "Посмотреть пример Java")

Ресурс, объявляемый в операторе try, неявно считается конечным. Это означает, что присвоить ресурс после того, как он
был создан, нельзя. Кроме того, область действия ресурса ограничивается пределами оператора try с ресурсами.

В одном операторе try можно организовать управление несколькими ресурсами. Для этого достаточно указать спецификацию
каждого ресурса через точку с запятой. Примером тому служит приведенная ниже версия программы CopyFile, переделанная
таким образом, чтобы использовать один оператор try с ресурсами для управления переменными fin и fout.

[Chapter13/Package02/CopyFileAutoClose - Пример оператора try с двумя ресурсами](https://github.com/Vladlena2/BookJava2/blob/master/Chapter13/Package02/CopyFileAutoClose.java "Посмотреть пример Java")

У оператора *try с ресурсами* имеется еще одна особенность, о которой стоит упомянуть. Когда выполняется блок оператора
try, существует вероятность того, что исключение, возникающее в блоке оператора try, приведет к другому исключению,
которое произойдет в тот момент, когда ресурс закрывается
в блоке оператора finally. Если это обычный оператор try, то первоначальное исключение теряется, будучи вытесненным
вторым исключением. А если используется оператор try с ресурсами, то второе исключение подавляется, но не теряется.
Вместо этого оно добавляется в список подавленных исключений, связанных
с первым исключением. Доступ к списку подавленных исключений может быть пол учен с помощью метода gеtSupprеssеd(),
определенного в классе Throwаblе.
</details>

<details><summary>Чтение и запись файлов. FileInputStream и FileOutputStream</summary>

**Запись файлов и класс FileOutputStream**

Класс *FileOutputStream* предназначен для записи байтов в файл. Он является производным от класса OutputStream, поэтому
наследует всю его функциональность.
Через конструктор класса FileOutputStream задается файл, в который производится запись. Класс поддерживает несколько
конструкторов:
```java
FileOutputStream(String filePath)
FileOutputStream(File fileObj)
FileOutputStream(String filePath, boolean append)
FileOutputStream(File fileObj, boolean append)
```
Файл задается либо через строковый путь, либо через объект File. Второй параметр - append задает способ записи: eсли он
равен true, то данные дозаписываются в конец файла, а при false - файл полностью перезаписывается.  
Например, запишем в файл строку:

[Chapter13/Package02/WriteFile - Пример записи строки в файл TEST.txt](https://github.com/Vladlena2/BookJava2/blob/master/Chapter13/Package02/WriteFile.java "Посмотреть пример Java")

Для создания объекта FileOutputStream используется конструктор, принимающий в качестве параметра путь к файлу для
записи. Если такого файла нет, то он автоматически создается при записи. Так как здесь записываем строку, то ее надо
сначала перевести в массив байтов. И с помощью метода write строка записывается в файл.
При этом необязательно записывать весь массив байтов. Используя перегрузку метода write(), можно записать и одиночный
байт:
```java
fos.write(buffer[0]); // запись первого байта
```

**Чтение файлов и класс FileInputStream**

Для считывания данных из файла предназначен класс *FileInputStream*, который является наследником класса InputStream и
поэтому реализует все его методы.

Для создания объекта FileInputStream мы можем использовать ряд конструкторов. Наиболее используемая версия конструктора
в качестве параметра принимает путь к считываемому файлу:
```java
FileInputStream(String fileName) throws FileNotFoundException
```
Если файл не может быть открыт, например, по указанному пути такого файла не существует, то генерируется исключение *
FileNotFoundException*.  
Считаем данные из ранее записанного файла (TEST.txt) и выведем на консоль:

[Chapter13/Package02/ReadFile - Пример чтения файла TEST.txt](https://github.com/Vladlena2/BookJava2/blob/master/Chapter13/Package02/ReadFile.java "Посмотреть пример Java")

В данном случае мы считываем каждый отдельный байт в переменную i:
```java
while((i = fin.read()) != -1) {
```
Когда в потоке больше нет данных для чтения, метод возвращает число -1.
Затем каждый считанный байт конвертируется в объект типа char и выводится на консоль.  
Подобным образом можно считать данные в массив байтов и затем производить с ним манипуляции:
```java
byte[] buffer = new byte[fin.available()];
// считаем файл в буфер
fin.read(buffer, 0, fin.available());

System.out.println("File data:");
for(int i=0; i<buffer.length;i++){
    System.out.print((char)buffer[i]);
}
```

Совместим оба класса и выполним чтение из одного и запись в другой файл:

[Chapter13/Package02/ReadWriteFile - Пример чтение из одного и запись в другой файл](https://github.com/Vladlena2/BookJava2/blob/master/Chapter13/Package02/ReadWriteFile.java "Посмотреть пример Java")

Классы FileInputStream и FileOutputStream предназначены прежде всего для записи двоичных файлов, то есть для записи и
чтения байтов. И хотя они также могут использоваться для работы с текстовыми файлами, но все же для этой задачи больше
подходят другие классы.

Еще один пример, в котором создаем для записи файл, далее записываем в него строку.  
Потом читаем и выводим на конслоь данные из этого файла и все это копируем в новый файл.

[Chapter13/Package02/WriteReadSaveToFile - Создание, чтение одного файла и копирование в другой файл](https://github.com/Vladlena2/BookJava2/blob/master/Chapter13/Package02/WriteReadSaveToFile.java "Посмотреть пример Java")
</details>

<details><summary>Чтение и запись текстовых файлов. Класс FileWriter. Класс FileReader</summary>

Для полноценной работы с текстовыми файлами служат совсем другие классы, которые являются наследниками абстрактных
классов *Reader* и *Writer*.

Класс *FileWriter* является производным от класса *Writer*. Он используется для записи текстовых файлов.
Чтобы создать объект *FileWriter*, можно использовать один из следующих конструкторов:
```
FileWriter(File file)
FileWriter(File file, boolean append)
FileWriter(FileDescriptor fd)
FileWriter(String fileName)
FileWriter(String fileName, boolean append)
```  
Так, в конструктор передается либо путь к файлу в виде строки, либо объект File, который ссылается на конкретный
текстовый файл. Параметр *append* указывает, должны ли данные дозаписываться в конец файла (если параметр равен true),
либо файл должен перезаписываться.

Класс *FileReader* наследуется от абстрактного класса *Reader* и предоставляет функциональность для чтения текстовых
файлов.
Для создания объекта *FileReader* мы можем использовать один из его конструкторов:
```java
FileReader(String fileName) 
FileReader(File file)
FileReader(FileDescriptor fd)
```  

[Chapter13/Package02/FileWriterReaderDemo - Записать текст в файл и прочитать](https://github.com/Vladlena2/BookJava2/blob/master/Chapter13/Package02/FileWriterReaderDemo.java "Посмотреть пример Java")
</details>

<details><summary>Модификаторы доступа transient и volatile</summary>

В языке J ava определяются два интересных модификатора доступа: *transient* и *volatile*. Эти модификаторы
предназначены для особых случаев. Когда переменная-экземпляр объявлена как transient, ее значение не должно
сохраняться, когда сохраняется объект, как показано ниже.

```java
class T {
    transient int а; //не сохранится
    int b; // сохранится
} 
```

Если в данном примере кода объект типа т записывается в область постоянного хранения, то содержимое переменной а не
должно сохраняться, тогда как содержимое переменной b должно быть сохранено.

Модификатор доступа volatile сообщает компилятору, что модифицируемая им переменная может быть неожиданно изменена в
других частях программы.
Одна из таких ситуаций возникает в многопоточных программах, где иногда в двух или больше потоках исполнения
разделяется
общая переменная. Из соображений эффективности в каждом потоке может храниться своя закрытая копия этой
переменной. Настоящая (или главная) копия переменной обновляется в разные моменты, например при входе в
синхронизированный метод. Такой подход вполне работоспособен, но не всегда оказывается достаточно эффективным. Иногда
требуется, чтобы главная копия переменной постоянно отражала ее текущее состояние. И для этого достаточно объявить
переменную как volatile, предписав тем самым компилятору всегда использовать главную копию этой переменной
(или хотя бы поддерживать любые закрытые ее копии обновляемыми по главной копии, и наоборот). Кроме того, доступ к
главной копии переменной должен осуществляться в том порядке, в каком он определен в самой программе.

[Chapter13/Package03/InstanceOf - Продемонстрировать применение операции instanceof](https://github.com/Vladlena2/BookJava2/blob/master/Chapter13/Package03/InstanceOf.java "Посмотреть пример Java")
</details>

<details><summary>Применение операции instanceof</summary>

Иногда тип объекта полезно выяснить во время выполнения. Например, в одном потоке исполнения объекты разных типов могут
формироваться, а в другом потоке исполнения - использоваться. В таком случае удобно выяснить тип каждого объекта,
получаемого в обрабатывающем потоке исполнения. Тип объекта во время выполнения не менее важно выяснить и в том
случае,
когда требуется приведение типов. В языке Java неправильное приведение типов влечет за собой появление ошибок во время
выполнения.

Для разрешения этого вопроса в Java предоставляется операция времени выполнения *instanceof*, которая имеет следующую
общую форму:
```java
ссылка_на_объект instanceof тип
```   
Здесь *ссылка_на_объект* обозначает ссылку на экземпляр класса, а тип - конкретный тип этого класса. Если *
ссылка_на_объект* относится к указанному типу или может быть приведена к нему, то вычисление операции *instanceof*
дает
в итоге логическое значение *true*, а иначе - логическое значение *false*. Таким образом, операция *instanceof* - это
средство, с помощью которого программа может получить сведения об объекте во время выполнения.

</details>

<details><summary>Модификатор доступа strictfp</summary>

Объявляя класс, метод или интерфейс с модификатором доступа *strictfp*, можно гарантировать, что вычисления с плавающей
точкой будут выполняться таким же образом, как и в первых версиях Java. Если класс объявляется с модификатором
доступа *
strictfp*, все его методы автоматически модифицируются как *strictfp*.

Например, в приведенной ниже строке кода компилятору Java сообщается, что во всех методах, определенных в классе
MyClass, следует использовать исходную модель вычислений с плавающей точкой. Откровенно говоря, большинству
программистов вряд ли понадобится модификатор доступа *strictfp*, поскольку он касается лишь небольшой категории
задач.
```java
strictfp class MyClass { // ...
``` 

</details>

<details><summary>Платформенно-ориентированные методы</summary>

Иногда, хотя и редко, возникает потребность вызвать подпрограмму, написанную на другом языке, а не на Java. Как
правило, такая подпрограмма существует
в виде исполняемого кода для ЦП и той среды, в которой приходится работать, т.е. в виде платформенно-ориентированного
кода. Такую подпрограмму, возможно, потребуется вызвать для повышения скорости ее выполнения. С другой стороны, может
возникнуть потребность работать со специализированной сторонней библиотекой, например с пакетом статистических
расчетов.

Для объявления платформенно-ориентированных методов в Java предусмотрено ключевое слово *native*. Однажды объявленные
как *native*, эти методы могут быть вызваны из прикладной программы на Java таким же образом,
как и любой другой метод. Механизм, применяемый для внедрения платформенно-ориентированного кода в прикладные
программы
на Java, называется JNI (*Java Native Interface - платформенно-ориентированный интерфейс Java*).

Чтобы объявить платформенно-ориентированный метод, его имя следует предварить модификатором доступа *native*, но не
определять тело метода, как показано ниже.
```java
public native int meth();
```
Объявив платформенно-ориентированный метод, необходимо написать его и предпринять ряд относительно сложных шагов, чтобы
связать его с кодом Java. Большинство платформенно-ориентированных методов пишутся на С.

</details>

<details><summary>Применение ключевого слова assert</summary>

Ключевое слово *assert* используется на стадии *разработки* программ для создания так называемых утверждений - условий,
которые должны быть *истинными* во время выполнения программы. Если во время выполнения программы условие оказывается
истинным, то никаких действий больше не выполняется. Но если условие окажется ложным, то генерируется исключение
типа *
AssertionError*. Утверждения часто применяются с целью проверить, действительно ли выполняется некоторое ожидаемое
условие. В коде окончательной версии программы утверждения, как правило, отсутствуют.

Ниже приведен пример программы, демонстрирующий применение оператора *assert*. В этом примере проверяется, возвращает
ли метод getnum() положительное значение.

[Chapter13/Package03/AssertDemo - Продемонстрировать применение оператора assert](https://github.com/Vladlena2/BookJava2/blob/master/Chapter13/Package03/AssertDemo.java "Посмотреть пример Java")

Для правильного понимания утверждений очень важно иметь в виду следующее: на них нельзя полагаться для выполнения
каких-нибудь конкретных действий в программе. Дело в том, что отлаженный код окончательной версии программы будет
выполняться с *отключенным* режимом проверки утверждений.

Благодаря утверждениям, строки кода с оператором *assert* можно не удалять из окончательного варианта кода программы.

**Параметры включения и отключения режима проверки утверждений.**

Чтобы *включить* режим проверки утверждений в пакете MyPack, достаточно ввести следующее:
```
-ea:MyPack ...
```

Чтобы *отключить* режим проверки утверждений, следует ввести:
```
-da:MyPack ...
```

Кроме того, класс можно указать с параметром -еа или -da. В качестве примера ниже показано, как включить режим проверки
утверждений отдельно в классе AssertDemo.
```
-ea:AssertDemo
``` 
</details>

<details><summary>Статический импорт</summary>

В языке Java имеется языковое средство, расширяющее возможности ключевого слова import и называемое *статическим
импортом*. Оператор import, предваряемый ключевым словом static, можно применять для импорта статических членов класса
или интерфейса. Благодаря статическому импорту появляется возможность ссылаться на статические члены непосредственно
по
именам, не уточняя их именем класса. Это упрощает и сокращает синтаксис, требующийся для работы со статическими
членами.
```java
// Вычислить длину гипотенузы прямоугольного треугольника
...
// Имена методов уточнены именем их класса Math
hypot = Math.sqrt(Math.pow(sidel, 2) + Math.pow(side2, 2));
...

// Используем статический импортом для доступ к встроенным в Java методам
import static java.lang.Mat.*;

...
// Здесь методы sqrt() и pow() можно вызывать непосредственно, опуская имя их Класса 
hypot = sqrt(pow(sidel, 2) + pow(side2, 2)); 
...

```
*Статический импорт* следует применять на тот случай, если статические члены применяются многократно, в частности при
выполнении целого ряда математических вычислений. В сущности, этим языковым средством стоит пользоваться, но только не
злоупотреблять им.
</details>

<details><summary>Вызов перегружаемых конструкторов по ссылке this()</summary>

Пользуясь *перегружаемыми конструкторами*, иногда удобно вызывать один конструктор из другого. Для этого в Java имеется
еще одна форма ключевого слова this. В общем виде эта форма выглядит следующим образом:
```java
this(список_аргументов)
```
По ссылке this() сначала выполняется *перегружаемый конструктор*, который соответствует заданному *списку_аргументов*,
а затем - любые операторы, находящиеся в теле исходного конструктора, если таковые имеются. Вызов конструктора по
ссылке
this() должен быть *первым* оператором в конструкторе.
Рассмотрим сначала приведенный ниже пример класса, в котором ссылка this() *не употребляется*.

Этот класс содержит три конструктора, каждый из которых инициализирует значения полей а и b. Первому конструктору
передаются отдельные значения для инициализации полей а и b. Второй конструктор принимает только одно значение и
присваивает его обоим полям, а и b. А третий присваивает полям а и b нулевое значение по умолчанию.
```java
class MyClass {
   int a;
   int b;
   // инициализировать поля а и b по отдельности
   MyClass(int i, int j) {
        a = i;
       b = j;    
    }
   // присвоить полям а и b нулевое значение по умолчанию
    MyClass() {
     a = 0;
      b = 0;
    }   
}
```

Используя ссылку this(), приведенный выше класс MyClass можно переписать следующим образом. В данной версии класса
MyClass значения непосредственно присваиваются полям а и b только в конструкторе MyClass (int, int). А два других
конструктора просто вызывают первый конструктор (прямо или косвенно) по ссылке this().
```java
class MyClass {
    int a;
    int b;
    // инициализировать поля а и b по отдельности
   MyClass(int i, int j) {
       a = i;
        b = j;    
    }
    // инициализировать поля а и b одним и тем же значением
   MyClass(int i) {
       this(i, i); // по этой ссылке вызывается конструктор MyClass(i, i);
    }


    // присвоить полям а и b нулевое значение по умолчанию
    MyClass() {
        this(0); // по этой ссылке вызывается конструктор MyClass(O)
  }   
}
```  
Одной из причин, по которой стоит вызывать перегружаемые конструкторы по ссылке this(),служит потребность избежать
дублирования кода. Зачастую сокращение дублированного кода ускоряет загрузку классов, поскольку объектный
код становится компактнее. Это особенно важно для программ, доставляемых через Интернет, когда время их загрузки
критично. Применение ссылки this() позволяет также оптимально структурировать прикладной код, когда конструкторы
содержат большой объем дублированного кода.

Следует также иметь в виду, что вызов очень коротких конструкторов, как, например, из класса MyClass, по ссылке this()
зачастую лишь незначительно увеличивает размер объектного кода. (В некоторых случаях никакого уменьшения объема
объектного кода вообще не происходит.) Дело в том, что байт-код, который устанавливается и возвращается из вызова
конструктора по ссылке this(), добавляет инструкции в объектный файл. Поэтому в таких случаях вызов конструктора по
ссылке this(), несмотря на исключение дублирования кода, не даст значительной экономии времени загрузки, но может
повлечь за собой дополнительные издержки на создание каждого объекта. Поэтому ссылка this() больше всего подходит для
вызова тех конструкторов, которые содержат большой объем кода инициализации, а не тех, которые просто устанавливают значения в нескольких полях.

Вызывая конструкторы по ссылке this(), следует учитывать следующее. Вопервых, при вызове конструктора по ссылке
this() *нельзя* использовать переменные экземпляра класса этого конструктора. И, во-вторых, в одном и том же
конструкторе *нельзя* использовать ссылки super() и this(), поскольку каждая из них должна быть первым оператором в
конструкторе.
</details>

<details><summary>Компактные профили Java API</summary>

В версии JDK 8 внедрено средство, позволяющее организовать подмножества
библиотеки прикладных программных интерфейсов API в так называемые *компактные профили*. Они обозначаются следующим
образом: *compact1, compact2 и cornpactЗ*. Каждый такой профиль содержит подмножество библиотеки. Более того,
компактный
профиль *compact2* включает в себя весь профиль *compact1*, а компактный профиль *compactЗ* - весь профиль *compact2*.
Следовательно, каждый последующий компактный профиль строится на основании предыдущего. Преимущество компактных
профилей
заключается в том, что прикладной
программе не нужно загружать библиотеку полностью. Применение компактных профилей позволяет сократить размер
библиотеки,
а следовательно, выполнять некоторые категории прикладных программ на тех устройствах, где отсутствует полная
поддержка
прикладного программного интерфейса Java API. Благодаря компактным профилям удается также сократить время, требующееся
для загрузки программы. В документации на прикладной программный интерфейс Java API
версии JDK 8 указывается, к какому именно элементу этого прикладного интерфейса принадлежит компактный профиль, если
это
вообще имеет место. Следует, однако, иметь в виду, что в версии JDK 9 на смену компактным профилям пришли внедренные в
ней модули.
</details>

</blockquote>
</details>

<details ГЛАВА 14><summary>ГЛАВА 14. "Обобщения"</summary>

<details><summary>Что такое обобщения</summary>

*Обобщения* - это *параметризованные типы*. Такие типы позволяют объявлять классы, интерфейсы и методы, где тип данных,
которыми они оперируют, указан в виде параметра. Используя обобщения, можно, например, создать единственный класс,
который будет автоматически обращаться с разнотипными данными. Классы, интерфейсы или методы, оперирующие
параметризованными типами, называются *обобщенными*.

Благодаря *обобщениям* все операции приведения типов выполняются автоматически и неявно. Таким образом, обобщения
расширили возможности повторного использования кода, позволив делать это легко и безопасно.

**Простой пример обобщения**

В приведенной ниже программе определяются два класса. Первый из них - *обобщенный* класс Gen, второй - *
демонстрационный* класс GenDemo, в котором используется *обобщенный* класс Gen.

[Chapter14/Package01/GenDemo - Простой обобщенный класс](https://github.com/Vladlena2/BookJava2/blob/master/Chapter14/Package01/GenDemo.java "Посмотреть пример Java")

Обратите внимание на объявление класса Gen в следующей строке кода:
```java
class Gen<T> {
```  
Здесь T обозначает имя параметра типа. Это имя используется в качестве заполнителя, вместо которого в дальнейшем
подставляется имя конкретного типа, передаваемого классу Gen при создании объекта. Это означает, что обозначение T
применяется в классе Gen всякий раз, когда требуется параметр типа. Обратите внимание на то, что обозначение Т
заключено
в угловые скобки ( < > ). Этот синтаксис
может быть обобщен. Всякий раз, когда объявляется параметр типа, он указывается в угловых скобках. В классе Gen
применяется параметр типа, и поэтому он является обобщенным классом, относящимся к так называемому параметризованному
типу.

Далее тип Т используется для объявления объекта оb:
```java
T оb; //объявить объект типа T
```  
Параметр типа Т - это место для *подстановки* конкретного типа, который указывается в дальнейшем при создании объекта
класса Gen. Это означает, что *объект оb станет объектом того типа, который будет передан в качестве параметра типа*
T.
Так, если передать тип String в качестве параметра типа Т, то такой экземпляр объекта оb будет иметь тип String.

Рассмотрим конструктор Gen().
```java
Gen (T o) {
    ob = o;
}
```  
Параметр o имеет тип T. Это означает, что конкретный тип параметра о определяется с помощью параметра типа Т,
передаваемого при создании объекта класса Gen. А поскольку параметр о и переменная экземпляра оЬ относятся к типу T,
то
они получают одинаковый конкретный тип при создании объекта класса Gen.
Параметр типа Т может быть также использован для указания типа, возвращаемого методом, как показано ниже на примере
метода getob(). Объект оb также относится к типу Т, поэтому его тип совместим с типом, возвращаемым методом getob().
```java
T getob() {>
    return оb;
```  
Метод showType() отображает тип Т, вызывая метод getName() для объекта типа Class, возвращаемого в результате вызова
метода getClass() для объекта оЬ. Метод getClass() определен в классе Object, и поэтому он является членом всех
классов.
Этот метод возвращает объект типа Class, соответствующий типу того класса объекта, для которого он вызывается. В
классе
Class определяется метод getName(), возвращающий строковое представление имени класса.

Класс GenDemo служит для демонстрации обобщенного класса Gen. Сначала в нем создается версия класса Gen для целых
чисел, как показано ниже.
```java
Gen<Integer> iOb; 
```  
*Integer* - это аргумент типа, который передается в качестве параметра типа Т из класса Gen. Это объявление фактически
означает создание версии класса Gen, где все ссылки на тип Т преобразуются в ссылки на тип Integer. Таким образом, в
данном объявлении объект оb относится к типу Integer, и метод getob() возвращает тип Integer.

Компилятор Java на самом деле не создает разные версии класса Gen или любого другого обобщенного класса. Вместо этого
компилятор *удаляет* все сведения об обобщенных типах, выполняя необходимые операции приведения типов, чтобы сделать
поведение прикладного кода таким, как будто создана конкретная версия класса Gen. Таким образом, имеется только *одна*
версия класса Gen, которая существует в прикладной программе. Процесс удаления обобщенной информации об обобщенных
типах
называется *стиранием*.

В следующей строке кода переменной iOb присваивается ссылка на экземпляр целочисленной версии класса Gen:
```java
iOb = new Gen<Integer>(12345678);
```  
Когда вызывается конструктор Gen(), аргумент типа Integer также указывается. Это необходимо потому, что объект (в
данном случае - iOb), которому присваивается ссылка, относится к типу Gen<Integer>. Следовательно, ссылка,
возвращаемая
операцией new, также должна относиться
к типу Gen<Integer>. В противном случае во время компиляции возникает ошибка. Например, следующее присваивание вызовет
ошибку во время компиляции:
```java
iOb = new Gen<DouЬle>(12345678.0); // ОШИБКА!!!
```  
Переменная iOb относится к типу Gen<Integer>, поэтому она не может быть использована для присваивания ссылки типа
Gen<DouЬle>. Такая проверка типа является одним из основных преимуществ обобщений, потому что она обеспечивает типовую
безопасность.

Как следует из комментариев к данной программе, в приведенной ниже операции присваивания выполняется автоупаковка для
инкапсуляции значения 12345678 типа int в объекте типа Integer.
```java
iOb = new Gen<Integer>(12345678);
```  
*Обобщение* Gen<Integer> создает конструктор, принимающий аргумент типа Integer. А поскольку предполагается объект типа
Integer, то значение 12345678 автоматически упаковывается в этом объекте. Присваивание может быть указано и явным
образом, как показано ниже, но такой его вариант не дает никаких преимуществ.
```java
iOb = new Gen<Integer>(new Integer(12345678));
```  
Затем в данной программе отображается тип объекта оb в переменной iOb (в данном случае - тип Integer). А далее
получается значение объекта оb в следующей строке кода:
```java
int v = iOb.getob();
```  
Метод getob() возвращает обобщенный тип T, который был заменен на тип Integer при объявлении переменной экземпляра iOb.
Поэтому метод getob() также возвращает тип Integer, который автоматически распаковывается в тип
int и присваивается переменной v типа int. Следовательно, тип, возвращаемый методом getob(), не нужно приводить к типу
Integer. Безусловно, выполнять автоупаковку необязательно, переписав предыдущую строку кода так, как показано ниже. Но
автоупаковка позволяет сделать код более компактным.
```java
int v = iOb.getob().intValue();
```  
Далее в классе GenDemo объявляется объект типа Gen<String> следующим образом:
```java
Gen<String> sOb = new Gen<String>("текстовая строка");
```  
В качестве аргумента типа в данном случае указывается тип String, подставляемый вместо параметра типа Т в обобщенном
классе Gen. Это, по существу, приводит к созданию строковой версии класса Gen, что и демонстрируется в остальной части
программы.

</details>

<details><summary>Обобщения оперируют только ссылочными типами</summary>

Когда объявляется экземпляр *обобщенного типа*, аргумент, передаваемый в качестве *параметра типа*, должен относиться
к *ссылочному типу*, но ни в коем случае не к примитивному типу вроде int или char. Например, в качестве параметра T
классу Gen можно передать *тип любого класса*, но нельзя передать примитивный тип.

Безусловно, отсутствие возможности использовать *примитивный тип* не является серьезным ограничением, поскольку можно
применять *оболочки типов данных* (как это делалось в предыдущем примере программы) для инкапсуляции примитивных
типов.
Более того, механизм автоупаковки и автораспаковки в Java делает прозрачным применение оболочек типов данных.
</details>

<details><summary>Обобщенные типы различаются по аргументам типа</summary>

В отношении обобщенных типов самое главное понять, что ссылка на одну конкретную версию обобщенного типа несовместима с
другой версией того же самого обобщенного типа. Так, если ввести следующую строку кода в предыдущую программу, то при
ее
компиляции возникнет ошибка:
```java
iOb = sOb; // НЕВЕРНО!!!
```  
Несмотря на то что переменные экземпляра iOb и sOb относятся к типу Gen<T>, они являются *ссылками на разные типы
объектов*, потому что их параметры типов отличаются. Этим, в частности, обобщения обеспечивают типовую безопасность,
предотвращая подобного рода ошибки.
</details>

<details><summary>Каким образом обобщения повышают типовую безопасность</summary>

Дело в том, что обобщения *автоматически* гарантируют типовую безопасность во всех операциях, где задействован
обобщенный класс Gen. В процессе его применения исключается потребность в явном приведении и ручной проверке типов в
прикладном коде.  
Пример программы, в которой создается *необобщенный* эквивалент класса Gen:

[Chapter14/Package02/NonGenDemo - Продемонстрировать необобщенный класс](https://github.com/Vladlena2/BookJava2/blob/master/Chapter14/Package02/NonGenDemo.java "Посмотреть пример Java")

В классе NonGen все ссылки на тип Т заменены ссылками на тип Object. Это позволяет хранить в классе NonGen объекты
любого типа, как и в обобщенном классе Gen. Но это не позволяет компилятору Java получить какиенибудь подлинные
сведения
о типе данных, фактически сохраняемых в объекте
класса NonGen, что плохо по двум причинам. Во-первых, для извлечения сохраненных данных требуется явное приведение
типов. И во-вторых, многие ошибки несоответствия типов не могут быть обнаружены до времени выполнения.

Обратим внимание на следующую строку кода:
```java
int v = (Integer) iOb.getob();
```
Метод getob() возвращает тип Object, поэтому его нужно привести к типу Integer, чтобы выполнить автораспаковку и
сохранить значение в переменной v. Если убрать приведение типов, программа не скомпилируется. Если в ее версии с
обобщениями приведение типов производится неявно, то в версии без обобщений приведение должно быть сделано явно. Это
не
только неудобно, но и служит потенциальным источником ошибок.

Теперь рассмотрим следующий фрагмент кода в конце данной программы:
```java
// Этот код компилируется, но он принципиально неверный!!!
iOb = sOb;
v = (Integer) iOb.getOb(); // Ошибка!!! во время выполнения.
```
Здесь переменной экземпляра iOb присваивается значение переменной экземпляра sOb. Но переменная экземпляра sOb
ссылается на объект, содержащий символьную строку, а не целое число. Такое присваивание синтаксически корректно,
потому
что все ссылки типа NonGen одинаковы и любая ссылка типа NonGen
может указывать на любой другой объект типа NonGen. Но семантически эта операция присваивания неверна, что и отражено
в
следующей строке коде. Здесь тип, возвращаемый методом getob(),приводится к типу Integer, а затем делается попытка
присвоить полученное значение переменной v. Дело в том, что переменная экземпляра iOb теперь ссылается на объект,
хранящий данные типа String, а не Integer.  
К сожалению, без обобщений компилятор Java просто не в состоянии обнаружить эту ошибку. Вместо этого во время
выполнения генерируется исключение при попытке привести к типу Integer.

Возможность создавать *типизированный* (т.е. обеспечивающий типовую безопасность) код, в котором ошибки несоответствия
типов перехватываются *компилятором*, является главным преимуществом обобщений.

Благодаря *обобщениям* ошибки, возникающие во время выполнения, преобразуются в ошибки, обнаруживаемые во время
компиляции. В этом и заключается главное преимущество обобщений.
</details>

<details><summary>Обобщенный класс с двумя параметрами типа</summary>

Для обобщенного типа можно объявлять не только один параметр. Несколько *параметров типа* можно указать списком через
запятую. Например, приведенный ниже класс TwoGen является переделанным вариантом класса Gen, принимающим два параметра
типа.

[Chapter14/Package03/TwoGenDemo - Продемонстрировать применение класса ТwoGen](https://github.com/Vladlena2/BookJava2/blob/master/Chapter14/Package03/TwoGenDemo.java "Посмотреть пример Java")
</details>

<details><summary>Общая форма обобщенного класса</summary>

Синтаксис, представленный в предыдущих примерах программ, может быть обобщен. Ниже показано, как выглядит синтаксис
объявления обобщенного класса.
```
  class имя_класса<список_параметров_типа> { // ...
```  
А синтаксис объявления ссылки на обобщенный класс и создание его экземпляра полностью выглядит следующим образом:
```
имя_класса<список_аргументов_типа> имя_переменной
new имя_класса<список_аргументов_типа>  
(список_аргументов_констант); 
```
</details>

<details><summary>Ограниченные типы</summary>

Допустим, что требуется создать обобщенный класс с методом, возвращающим среднее значение массива чисел. С помощью
этого класса требуется получить среднее значение из целых чисел, а также чисел с плавающей точкой одинарной и двойной
точности. Таким образом, тип числовых данных требуется указать обобщенно, используя параметр типа.

Для подобных случаев в Java предоставляются *ограниченные типы*. Указывая параметр типа, можно наложить *ограничение* в
виде верхней границы, где объявляется суперкласс, от которого должны быть унаследованы все аргументы типов.
С этой целью вместе с параметром указывается ключевое слово *extends*:
```java
<Т extends суперкласс>
```  
Это означает, что параметр типа T может быть заменен только указанным *суперклассом* или его подклассами.
Следовательно, *суперкласс* объявляет верхнюю границу включительно.

[Chapter14/Package04/StatsDemo - Продемонстрировать ограничение параметра типа](https://github.com/Vladlena2/BookJava2/blob/master/Chapter14/Package04/StatsDemo.java "Посмотреть пример Java")
</details>

<details><summary>Применение метасимвольных аргументов</summary>

*Метасимвольный аргумент* обозначается знаком **"?"** и представляет *неизвестный* тип.

Например, в классе Stats, рассмотренном в предыдущем разделе, предполагается, что в него требуется ввести метод
sameAvg(), где определяется, содержат ли два объекта типа Stats массивы, дающие *одинаковое среднее значение*
независимо
от типа числовых значений в них. Так, если один объект содержит значения 1.0, 2.0 и 3.0 типа *doublе*, а другой - *
целочисленные* значения 1, 2 и 3, то их *среднее значение будет одинаковым*.

Применяя метасимвольный аргумент, метод sameAvg() можно написать, следующим образом:
```java
// Обратите внимание на применение метасимвола постановки
boolean sameAvg(Stats<?> ob) {
   if (average() == ob.average())
       return true;
  return false;
}
```
Здесь *метасимвольный* аргумент типа Stats<?> совпадает с любым объектом класса Stats, что позволяет сравнивать средние
значения любых двух объектов класса Stаts.

[Chapter14/Package05/WildcardDemo - Продемонстрировать применение метасимволов подстановки в качестве аргументов](https://github.com/Vladlena2/BookJava2/blob/master/Chapter14/Package05/WildcardDemo.java "Посмотреть пример Java")
</details>

<details><summary>Ограниченные метасимвольные аргументы</summary>

*Ограниченный* метасимвол подстановки задает верхнюю или нижнюю границу для аргумента типа. Это позволяет ограничить
типы объектов, которыми будет оперировать метод. Наиболее распространен метасимвол, который налагает ограничение
сверху
и создается с помощью оператора *extends* почти так же, как и ограниченный тип.

В общем, чтобы установить верхнюю границу для метасимвола, следует воспользоваться приведенной ниже формой
метасимвольного выражения:
```java
<? extends суперкласс>
```
Здесь *суперкласс* обозначает имя класса, который служит верхней границей. Не следует забывать, что это включающее
выражение, а следовательно, класс, заданный в качестве верхней границы (т.е. суперкласс), также находится в пределах
допустимых типов.

Имеется также возможность указать нижнюю границу для метасимвольного аргумента, введя оператор *super* в его
объявление. Ниже приведена общая форма ограничения метасимвольного аргумента снизу.
```java
<? super подкласс>
```
В данном случае допустимыми аргументами могут быть только те классы, которые являются суперклассами для указанного *
подкласса*. Это исключающее выражение, поскольку оно не включает в себя заданный *подкласс*.

[Chapter14/Package05/BoundedWildcard - Продемонстрировать Ограниченные метасимвольные аргументы](https://github.com/Vladlena2/BookJava2/blob/master/Chapter14/Package05/BoundedWildcard.java "Посмотреть пример Java")
</details>

<details><summary>Создание обобщенного метода</summary>

Рассмотрим объявление обобщенного метода isIn() в следующей строке кода:
```java
static <T extends Comparable<T>, V extends T>
   boolean isIn(T x, V[] y) {
}
```
Параметр типа объявляется *до* типа, возвращаемого методом. Тип T расширяет обобщенный тип *Comparable<T>*, где *
Comparable* - это интерфейс, объявляемый в пакете java.lang. В классе, реализующем интерфейс *Comparable*,
определяются
объекты, которые могут быть упорядочены. Следовательно, указание интерфейса *Comparable* в качестве верхней границы
гарантирует, что метод *isIn()* вполне применим к объектам, которые можно сравнивать. Интерфейс *Comparable* является
обобщенным, а параметр его типа обозначает тип сравниваемых объектов.

[Chapter14/Package06/GenMethDemo - Продемонстрировать простой обобщенный метод](https://github.com/Vladlena2/BookJava2/blob/master/Chapter14/Package06/GenMethDemo.java "Посмотреть пример Java")
</details>

<details><summary>Обобщенные конструкторы</summary>

Конструкторы также могут быть *обобщенными*, даже если их классы таковыми не являются.

[Chapter14/Package06/GenConsDemo - Использовать обобщенный конструктор](https://github.com/Vladlena2/BookJava2/blob/master/Chapter14/Package06/GenConsDemo.java "Посмотреть пример Java")

В конструкторе GenCons() задается параметр обобщенного типа, который может быть производным от класса Number, поэтому
конструктор GenCons() можно вызывать с любым числовым типом, включая Integer, Float или Double.
Несмотря на то, что класс GenCons не является обобщенным, его конструктор обобщен.
</details>

<details><summary>Обобщенные интерфейсы</summary>

Обобщенные интерфейсы объявляются таким же образом, как и обобщенные классы.
Общая синтаксическая форма обобщенного интерфейса.
```java
interface имя_интерфейса<список_параметров_типа> { // ... 
```
Здесь *список_параметров_типа* обозначает разделяемый запятыми список параметров типа. Когда *реализуется* обобщенный
интерфейс, следует указать аргументы типа.
```java
class имя_класса<список_параметров_типа>
      implements имя_интерфейса<список_аргументов_типа> ( 
```

Далее в приведенном примере, создается обобщенный интерфейс MinMax, где объявляются методы min() и max(), которые, как
предполагается, должны возвращать минимальное и максимальное значения из некоторого множества объектов.

Объявление обобщенного интерфейса MinMax:
```java
interface MinMax<T extends Comparable<T>> {
}
```
Параметр типа T ограничивается сверху интерфейсом Comparable. Интерфейс Comparable определен в пакете java.lang для
сравнения объектов. Параметр его типа обозначает тип сравниваемых объектов.

Далее интерфейс MinMax реализуется в классе ClassMinMax:
```java
class ClassMinMax<T extends Comparable<T>> implements MinMax<T> {
}
```
Параметр типа T сначала объявляется в классе MyClass, а затем передается интерфейсу MinMax. Интерфейсу MinMax требуется
тип класса, реализующего интерфейс Comparable, поэтому в объявлении класса, реализующего этот интерфейс (в данном
случае
- класса ClassMinMax), должно быть наложено такое же ограничение.
   Следовательно, однажды наложенное ограничение уже не нужно повторять в операторе implements.

[Chapter14/Package06/GenIFDemo - Пример применения обобщенного интерфейса](https://github.com/Vladlena2/BookJava2/blob/master/Chapter14/Package06/GenIFDemo.java "Посмотреть пример Java")

**Обобщенный интерфейс дает два преимущества:**  
*Во-первых*, он может быть реализован для разных типов данных.  
*Во-вторых*, он позволяет наложить ограничения на типы данных, для которых он может быть реализован.

</details>

<details><summary>Иерархии обобщенных классов</summary>

*Обобщенные* классы могут быть частью иерархии классов, как и любые другие *необобщенные* классы. Это означает, что
обобщенный класс может действовать в качестве суперкласса или подкласса. Главное отличие *обобщенных* иерархий
от *необобщенных* состоит в том, что в *обобщенной* иерархии любые аргументы типа, требующиеся обобщенному *
суперклассу*
, должны передаваться всеми *подклассами* вверх по иерархии. Это похоже на порядок передачи аргументов конструкторам
вверх по иерархии.

**Применение обобщенного суперкласса**

Приведем пример иерархии, в которой применяется обобщенный суперкласс.
```java
// Простая иерархия обобщенных классов
class Gen<T> {
  Т оb;
 
  Gen (Т о) {
     оb = о;
  }
  
  // возвратить объект оb
 T getOb() {
     return оb;
  }
}
// Подкласс, производный от класса Gen
class Gen2<T> extends Gen<T> {
  Gen2 (Т о) {
     super (о);
   }
}
```
В этой иерархии класс *Gen2* расширяет обобщенный класс *Gen*. Обратите внимание на объявление класса *Gen2* в
следующей строке кода:
```java
class Gen2<T> extends Gen<T> {
```
Параметр типа *T* указан в объявлении класса *Gen2* и передается классу *Gen* в выражении *extends*. Это означает, что
тип, передаваемый классу *Gen2*, будет также *передан* классу *Gen*. Например, в объявлении
```java
Gen2<Integer> num = new Gen2<Integer>(100);
```
тип *Integer* передается в качестве параметра типа классу *Gen*. Таким образом, объект *оb* в части *Gen* класса *Gen2*
будет иметь тип *Integer*.
Следует также иметь в виду, что параметр типа *T* используется в классе *Gen2* только для поддержки его суперкласса *
Gen*. Даже если *подкласс* обобщенного суперкласса не должен быть обобщенным, в нем все равно должны быть указаны
параметры типа, требующиеся его обобщенному *суперклассу*.
Если требуется, то *подкласс* может быть дополнен и своими параметрами типа.

[Chapter14/Package07/HierDemo - Пример обобщенного суперкласса и подкласса со своим параметром](https://github.com/Vladlena2/BookJava2/blob/master/Chapter14/Package07/HierDemo.java "Посмотреть пример Java")
</details>

<details><summary>Обобщенный подкласс</summary>

*Суперклассом* для *обобщенного* класса вполне может служить и *необобщенный* класс.  
В качестве примера представлена следующая программа:

[Chapter14/Package08/HierDemo2 - Пример обобщенного суперкласса и подкласса со своим параметром](https://github.com/Vladlena2/BookJava2/blob/master/Chapter14/Package08/HierDemo2.java "Посмотреть пример Java")
</details>

<details><summary>Сравнение типов в обобщенной иерархии во время выполнения</summary>

Для получения сведений о типе во время выполнения служит оператор *instanceof*.  
Оператор instanceof определяет, является ли объект экземпляром класса. Он возвращает логическое значение true, если
объект относится к указанному типу или может быть приведен к этому типу. Оператор i ns t anc ео f можно применять к
объектам обобщенных классов.  
В примере класса демонстрируются некоторые последствия совместимости типов в обобщенных иерархиях:

[Chapter14/Package09/HierDemo3 - Использовать оператор instanceof в иерархии обобщенных классов](https://github.com/Vladlena2/BookJava2/blob/master/Chapter14/Package09/HierDemo3.java "Посмотреть пример Java")

**Приведение типов**

Тип одного экземпляра обобщенного класса можно привести к другому только в том случае, если они совместимы и их
аргументы типа одинаковы. Например, следующее приведение типов из предыдущего примера программы:
```java
    (Gen<Integer>) iOb2 // допустимо
```
вполне допустимо, потому что объект iОb2 является экземпляром типа Gen<Integer>. А следующее приведение типов:
```java
   (Gen<Long>) iOb2 //недопустимо
```  
недопустимо, поскольку объект iOb2 не является экземпляром типа Gen<Long>.
</details>

<details><summary>Переопределение методов в обобщенном классе</summary>

Метод из обобщенного класса может быть переопределен, как и любой другой метод.

[Chapter14/Package10/OverrideGenMeth - Переопределение обобщенного метода в обобщенном классе](https://github.com/Vladlena2/BookJava2/blob/master/Chapter14/Package10/OverrideGenMeth.java "Посмотреть пример Java")
</details>

<details><summary>Выведение типов и обобщения</summary>

В версии JDK 7 был внедрен синтаксический элемент, позволяющий избежать повторного указания аргументов типа.
```java
    MyClass<lnteger, String> mcOb = new MyClass<>(99, "Строка");
```
Обратите внимание на то, что в правой части приведенного выше оператора, где создается экземпляр, просто указываются
угловые скобки(<>), обозначающие пустой список аргументов типа и называемые ромбовидным оператором. Этот оператор
предписывает компилятору вывести тип аргументов, требующихся конструктору в операции new. Главное преимущество
синтаксиса выведения типов заключается в том, что он короче и иногда значительно сокращает очень длинные операторы
объявления.

Когда выполняется выведение типов, синтаксис объявления для обобщенной ссылки и создания экземпляра имеет приведенную
ниже общую форму, где список аргументов типа конструктора в операции new пуст.
```
   имя_класса<список_аргументов_типа> имя_переменной = new имя_класса<>(список_аргументов_конструктора);
```
Выведение типов можно также выполнять и при передаче параметров. Так, если в класс MyClass вводится следующий метод:
```java
boolean isSame(MyClass<T, V> о) {
    if(ob1 == о.оb1 && оb2 == о.оb2) return true;
    else return false; 
```
то приведенный ниже вызов считается вполне допустимым.
```java
if(mcOb.isSame(new MyClass<>(88, "test")))
   System.out.println("Same");
```
В данном случае аргументы типа для аргумента, передаваемого методу isSame(), могут быть выведены из параметров типа.
</details>

</details>

</blockquote>
</details>
